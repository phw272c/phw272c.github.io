<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lab 2 - Spatial variation in risk | Applied Spatial Data Science for Public Health</title>
<meta name="generator" content="Jekyll v3.9.1" />
<meta property="og:title" content="Lab 2 - Spatial variation in risk" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurrences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz." />
<meta property="og:description" content="This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurrences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz." />
<link rel="canonical" href="http://localhost:4000/lab-2/" />
<meta property="og:url" content="http://localhost:4000/lab-2/" />
<meta property="og:site_name" content="Applied Spatial Data Science for Public Health" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-09T00:00:00-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lab 2 - Spatial variation in risk" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-09T00:00:00-08:00","datePublished":"2023-03-09T00:00:00-08:00","description":"This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurrences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz.","headline":"Lab 2 - Spatial variation in risk","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/lab-2/"},"url":"http://localhost:4000/lab-2/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Applied Spatial Data Science for Public Health" /></head>
<body>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Lab 2 - Spatial variation in risk</h1>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This week we are going to explore methods to understand and predict risk
across space from point data. These may be point level data
(i.e. measurements of something of interest at particular points) or
point process data (i.e. occurrences of events in a given area). When
you load this week’s libraries, it may prompt you to download
<a href="https://www.xquartz.org/">XQuartz</a>.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">Metrics</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geoR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">gtools</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">lme4</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">oro.nifti</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgdal</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>First load up some obfuscated malaria case-control data from Namibia.
This is comprised of latitudes and longitudes of cases and controls.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/CaseControl.csv"</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">CaseControl</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   household_id       lat     long case
## 1            1 -17.51470 16.05666    1
## 2            2 -17.82175 16.15147    1
## 3            3 -17.78743 15.93465    1
## 4            4 -17.51352 15.83933    1
## 5            5 -17.63668 15.91185    1
## 6            6 -17.64459 16.16105    1
</code></pre></div></div>

<p>To set ourselves up for further analyses, let’s create objects of just
cases and just controls.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Create a new object with just the cases, recoded as a number 1</span><span class="w">
</span><span class="n">Cases</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">1</span><span class="p">,]</span><span class="w">

</span><span class="c1">#Create a new object with just the controls, recoded as a number 0</span><span class="w">
</span><span class="n">Controls</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">0</span><span class="p">,]</span><span class="w">
</span></code></pre></div></div>

<p>We are also going to create a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code> of the
case-control data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"lat"</span><span class="p">)],</span><span class="w">
                                           </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"household_id"</span><span class="p">,</span><span class="w"> </span><span class="s2">"case"</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>And get hold of a boundary file for Namibia.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NAM_Adm0</span><span class="o">&lt;-</span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s1">'GADM'</span><span class="p">,</span><span class="n">country</span><span class="o">=</span><span class="s1">'NAM'</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="m">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning in raster::getData("GADM", country = "NAM", level = 0): getData will be removed in a future version of raster
## . Please use the geodata package instead
</code></pre></div></div>

<p>Let’s plot and see what we have. First, create a color scheme based on
the case classification (0 or 1).</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case_color_scheme</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"red"</span><span class="p">),</span><span class="w"> </span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then, plot</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">CaseControl_SPDF</span><span class="p">,</span><span class="w"> 
                                              </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">case_color_scheme</span><span class="p">(</span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">),</span><span class="w">
                                              </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-8-1.png" alt="" /></p>

<h2 id="risk-mapping-using-kernel-density">Risk Mapping using Kernel Density</h2>

<p>To generate a kernel density estimate, we first need to generate point
pattern object of points (aka ppp). First, we need to define a window
defining the population from which the cases arose.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nam_Owin</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">xrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">),</span><span class="n">yrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now we can define the ppp object of the cases.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Cases_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">Cases</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">Cases</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-10-1.png" alt="" /></p>

<p>We can now generate and plot a kernel density estimate of cases.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">)))</span><span class="w">
</span><span class="n">case_density</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">case_density</span><span class="p">)</span><span class="w"> </span><span class="c1"># Units are intensity of points per unit square</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-11-1.png" alt="" /></p>

<p>It’s possible to use different bandwidths. The larger the bandwidth, the
smoother the density estimate. You can also automatically chose a
bandwidth based on a variety of methods. Investigate <code class="language-plaintext highlighter-rouge">?bw.ppl</code> for more
information.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.02</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.02"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.1</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.1"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="n">bw.ppl</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Automatically selected bandwidth"</span><span class="p">)</span><span class="w"> </span><span class="c1"># automatic bandwidth selection based on cross-validation</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-12-1.png" alt="" /></p>

<p>If you want to map using leaflet, you have to convert the density object
to a rasterLayer with a coordinate reference system.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create raster</span><span class="w">
</span><span class="n">density_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">bw.ppl</span><span class="p">))</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">density_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">)</span><span class="w">

</span><span class="c1"># Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">density_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-13-1.png" alt="" /></p>

<p>But this is just a density of cases, i.e. it doesn’t account for the
denominator - the controls. To do this, we can use the Kelsall &amp; Diggle
method (see paper in course notes), which calculates the ratio of the
density estimate of cases:controls.</p>

<p>First we have to add ‘marks’ to the points. Marks are just values
associated with each point such as case or control (1/0).</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">marks</span><span class="o">=</span><span class="n">as.factor</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now we can use the <code class="language-plaintext highlighter-rouge">relrisk</code> function from the spatstat package to look
at the risk of being a case relative to the background population. In
order to obtain an output of relative risk, we must specify relative =
TRUE in the code line (the probability of being a case, relative to
probability of being a control). If the ‘relative’ argument is not
included in the code line the argument is technically specified as
‘FALSE’ since this is the default and the output is the probability of
being a case. You can set sigma (bandwidth), but the default is to use
cross-validation to find a common bandwidth to use for cases and
controls. See <code class="language-plaintext highlighter-rouge">?bw.relrisk</code> for more details.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">risk_est</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-15-1.png" alt="" /></p>

<h2 id="obtaining-a-relative-risk-of-being-a-case">Obtaining a relative risk of being a case</h2>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">rel_risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">rel_risk_est</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-16-1.png" alt="" /></p>

<p>To plot on a web map, first specify the projection</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">risk_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">risk_est</span><span class="p">)</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then define a color palette</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">palette</span><span class="o">=</span><span class="n">tim.colors</span><span class="p">(</span><span class="m">64</span><span class="p">),</span><span class="w"> </span><span class="n">domain</span><span class="o">=</span><span class="n">values</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">),</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then plot with leaflet</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">(</span><span class="s2">"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pal</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-19-1.png" alt="" /> <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>{=html} ##
Interpolation of point (prevalence etc.) data First load Ethiopia
malaria prevalence data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/mal_data_eth_2009_no_dups.csv"</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Get the Ethiopia Adm 1 level boundary file using the raster package
which provides access to GADM data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning in raster::getData("GADM", country = "ETH", level = 1): getData will be removed in a future version of raster
## . Please use the geodata package instead
</code></pre></div></div>

<h3 id="inverse-distance-weighting-idw">Inverse distance weighting (IDW)</h3>

<p>Inverse distance weighting is one method of interpolation. To perform
IDW using the spatstat package, per kernel density estimates, we have to
create a ppp object with the outcome we wish to interpolate as marks. We
have to start by setting the observation window. In this case, we are
going to use the bounding box around Oromia State from which these data
were collected. To set the window for the <code class="language-plaintext highlighter-rouge">ppp</code> function, we need to use
the <code class="language-plaintext highlighter-rouge">owin</code> function.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oromia</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">[</span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">NAME_1</span><span class="o">==</span><span class="s2">"Oromia"</span><span class="p">,]</span><span class="w">
</span><span class="n">oromia_window</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">1</span><span class="p">,],</span><span class="w"> </span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">2</span><span class="p">,])</span><span class="w">
</span></code></pre></div></div>

<p>Then define a ppp of the prevalence data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_ppp</span><span class="o">&lt;-</span><span class="n">ppp</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
                         </span><span class="n">marks</span><span class="o">=</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">oromia_window</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Set the parameters for displaying multiple plots in one screen and plot
different IDW results NB: 1) power represents the power function we want
to use 2) ‘at’ can be ‘pixels’ where it generates estimates across a
grid of pixels or ‘points’ where it interpolates values at every point
using leave-one-out-cross validation</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.2"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.5"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.1"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 2"</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-24-1.png" alt="" /></p>

<p>To calculate the ‘best’ power to use, you can use cross-validation. This
is possible using the argument at=points when running the idw function.
There is no off the shelf function (that I know of) to do this, so you
have to loop through different power values and find the one that
produces the lowest error using cross-validation.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powers</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">0.05</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">0.05</span><span class="p">)</span><span class="w"> 
</span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">NULL</span><span class="w"> 
</span><span class="k">for</span><span class="p">(</span><span class="n">power</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">powers</span><span class="p">){</span><span class="n">CV_idw</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
  </span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">mse_result</span><span class="p">,</span><span class="w"> </span><span class="n">mse</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="n">CV_idw</span><span class="p">))</span><span class="w"> 
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>See which produced the lowest error</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimal_power</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">powers</span><span class="p">[</span><span class="n">which.min</span><span class="p">(</span><span class="n">mse_result</span><span class="p">)]</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">powers</span><span class="p">,</span><span class="w"> </span><span class="n">mse_result</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-26-1.png" alt="" /> Plot observed versus
expected with optimal power</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CV_idw_opt</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">optimal_power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="w"> </span><span class="n">CV_idw_opt</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Predicted prevalence"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-27-1.png" alt="" /></p>

<p>Plot using leaflet.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Convert to a raster</span><span class="w">
</span><span class="n">ETH_malaria_data_idw_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> 
                                          </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">))</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">

</span><span class="c1">#2. Define a color palette</span><span class="w">
</span><span class="n">colPal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">tim.colors</span><span class="p">(),</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[],</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">

</span><span class="c1"># 3. Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.7</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[])</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-28-1.png" alt="" /> <code class="language-plaintext highlighter-rouge">&lt;br&gt;</code>{=html} ### Kriging
We are going to use the GeoR package to perform kriging. First, we have
to create a geodata object with the package GeoR. This wants dataframe
of x,y and data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_geo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr"</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>We can plot a summary plot using the lowess option gives us LOWESS
curves for the relationship between x and y. LOWESS stands for locally
weighted scatterplot smoothing.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">lowess</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-30-1.png" alt="" /></p>

<p>It’s important to assess whether there is a first order trend in the
data before kriging. We can see from the plots of the prevalence against
the x and y coordinates that there isn’t really any evidence of such a
trend. Were there to be evidence, you can add <code class="language-plaintext highlighter-rouge">trend = '1st'</code> or
<code class="language-plaintext highlighter-rouge">trend = '2nd'</code> to the plot command to see the result after having
regressed prevalence against x and y using a linear and polynomial
effect respectively.</p>

<p>Now generate and plot a variogram. As a rule of thumb, its a good idea
to limit variogram estimation to half the maximum interpoint distance</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MaxDist</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)]))</span><span class="w">  </span><span class="o">/</span><span class="m">2</span><span class="w"> 
</span><span class="n">VarioCloud</span><span class="o">&lt;-</span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">option</span><span class="o">=</span><span class="s2">"cloud"</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">VarioCloud</span><span class="p">)</span><span class="w"> </span><span class="c1"># all pairwise comparisons</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-31-1.png" alt="" /> To make it easier to
interpret, we can bin points by distance. You can specify
<code class="language-plaintext highlighter-rouge">option = "bin"</code> but it’s the default so we left it out.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-32-1.png" alt="" /></p>

<p>It’s possible to change the way the variogram bins are constructed. Just
be careful not to have too few pairs of points in any distance class.
NB: <code class="language-plaintext highlighter-rouge">uvec</code> argument provides values to define the variogram binning
(e.g. let’s try bins of 0.2 decimal degrees, about 22 km).</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">,</span><span class="n">uvec</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0.01</span><span class="p">,</span><span class="n">MaxDist</span><span class="p">,</span><span class="m">0.2</span><span class="p">))</span><span class="w"> 
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<p>Let’s look at the number in each bin</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="o">$</span><span class="n">n</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1]  85 432 541 586 692 607 652 661 679 663 736 764 711 692 577 585 594 551 630
## [20] 724
</code></pre></div></div>

<p>What is the minimum? A rule of thumb is 30 in each bin</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">min</span><span class="p">(</span><span class="n">Vario</span><span class="o">$</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 85
</code></pre></div></div>

<p>Plot</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-36-1.png" alt="" /></p>

<p>We can now fit variogram model by minimized least squares using
different covariance models. In this case we are just going to use a
‘spherical’ and ‘exponential’ model.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_sph</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "sph"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "3.05" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.28256710551259e-05
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_exp</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"exp"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is exponential 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "exp"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "1.22" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.76112575299845e-05
</code></pre></div></div>

<p>Plot results</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"blue"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-38-1.png" alt="" /></p>

<p>Get summaries of the fits.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "spherical"
## 
## $spatial.component
##     sigmasq         phi 
## 0.000160867 3.048000000 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 8.043352e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.048
## 
## $sum.of.squares
##        value 
## 2.282567e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 8.043352e-05 1.608670e-04 3.048000e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "sph")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "exponential"
## 
## $spatial.component
##      sigmasq          phi 
## 0.0002281533 1.2192006253 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 3.042044e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.652398
## 
## $sum.of.squares
##        value 
## 2.643998e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 3.042044e-05 2.281533e-04 1.219201e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "exp")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div>

<p>In this case, the spherical model has a slightly lower sum of squares,
suggesting it provides a better fit to the data.</p>

<p>Now we have a variogram model depicting the covariance between pairs of
points as a function of distance between points, we can use it to Krig
values at prediction locations. To allow us to compare with IDW, first
get grid of points from the IDW example for comparison</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Create prediction grid</span><span class="w">
</span><span class="n">IDW</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">)</span><span class="w">
</span><span class="n">pred_grid_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">))</span><span class="w">
</span><span class="n">pred_grid_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sort</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">)))</span><span class="w">
</span><span class="n">pred_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="n">pred_grid_y</span><span class="p">)</span><span class="w">

</span><span class="c1"># 2. Now krig to those points</span><span class="w">
</span><span class="n">KrigPred</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige.conv</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="o">=</span><span class="n">pred_grid</span><span class="p">,</span><span class="w">
                       </span><span class="n">krige</span><span class="o">=</span><span class="n">krige.control</span><span class="p">(</span><span class="n">obj.model</span><span class="o">=</span><span class="n">VarioMod_sph</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## krige.conv: model with constant mean
## krige.conv: Kriging performed using global neighbourhood
</code></pre></div></div>

<p>Visualize predictions.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span><span class="p">(</span><span class="n">KrigPred</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">50</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-41-1.png" alt="" /></p>

<p>If you want to create a raster of your predictions, you can use the
<code class="language-plaintext highlighter-rouge">rasterFromXYZ</code> function.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KrigPred_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterFromXYZ</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="w">
                                 </span><span class="n">y</span><span class="o">=</span><span class="n">pred_grid_y</span><span class="p">,</span><span class="w">
                                 </span><span class="n">z</span><span class="o">=</span><span class="n">KrigPred</span><span class="o">$</span><span class="n">predict</span><span class="p">))</span><span class="w">

</span><span class="n">plot</span><span class="p">(</span><span class="n">KrigPred_raster</span><span class="p">)</span><span class="w">
</span><span class="n">points</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w">
       </span><span class="n">cex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-42-1.png" alt="" /></p>

<p>Generating cross-validated predictions in straightforward in geoR using
the
<a href="https://www.rdocumentation.org/packages/geoR/versions/1.8-1/topics/xvalid"><code class="language-plaintext highlighter-rouge">xvlalid</code></a>
function. Two types of validation are possible: 1. leaving-on-out cross
validation where each data location (all or a subset) is removed in turn
and predicted using the remaining locations, for a given model. 2.
External validation which can predict to locations outside of the
dataset. Here we will use the default leave-one-out cross validation for
all points.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xvalid_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot on log odds scale</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">predicted</span><span class="p">,</span><span class="w"> </span><span class="n">asp</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w">
     </span><span class="n">xlab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Cross-validated predicted prevalence"</span><span class="p">)</span><span class="w">
</span><span class="n">abline</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-43-1.png" alt="" /></p>

<p>You might notice that some of the kriged values are &lt;0. Since we are
trying to modeling probabilities this can’t be true. In these
situations, it is possible to apply a transformation to your data before
kriging and then back-transform results. One transformation useful for
probabilities is the logit transform (used in logistic regression). The
<code class="language-plaintext highlighter-rouge">logit</code> and <code class="language-plaintext highlighter-rouge">inv.logit</code> functions from the package <code class="language-plaintext highlighter-rouge">gtools</code> can be used
for this. Note that it doesn’t work if you have 0 values as you can’t
log(0). You can add a small amount to avoid this situation. The process
would look like this.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add small amount to avoid zeros</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">0.001</span><span class="w">

</span><span class="c1"># Apply logit transform and convert to geodata</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">logit</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="p">)</span><span class="w">
</span><span class="n">ETH_malaria_data_geo_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr_logit"</span><span class="p">)])</span><span class="w">

</span><span class="c1"># Fit (spherical) variogram</span><span class="w">
</span><span class="n">Vario_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_sph_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario_logit</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario_logit, cov.model = "sph"): initial values not provided
## - running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq  kappa
## initial.value "1.16"  "2.45" "0.15" "0.5"
## status        "est"   "est"  "est"  "fix"
## loss value: 448.598010419967
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get CV kriged predictions</span><span class="w">
</span><span class="n">xvalid_result_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph_logit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xvalid_result_inv_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">inv.logit</span><span class="p">(</span><span class="n">xvalid_result_logit</span><span class="o">$</span><span class="n">predicted</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="pop-quiz">Pop quiz</h2>

<ul>
  <li>How could you compare how well the best fitting IDW performs versus
kriging?</li>
  <li>Which appears to be more accurate?</li>
  <li>Can you visualize where predictions from IDW differ to kriging?</li>
  <li>Does inclusion of a trend surface improve kriging estimates?</li>
</ul>

<p>Answers
<a href="https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/code/week_3_cheat_sheet.R">here</a></p>

<h2 id="key-readings">Key readings</h2>

<h4 id="good-overview">Good overview</h4>

<p>Pfeiffer, D., T. P. Robinson, M. Stevenson, K. B. Stevens, D. J. Rogers
and A. C. Clements (2008). Spatial analysis in epidemiology, Oxford
University Press Oxford. Chapter 6.</p>

<h4 id="technical-paper-covering-kernel-estimation-of-relative-risk-key-reference-but-not-necessary-to-understand-in-detail">Technical paper covering kernel estimation of relative risk. Key reference but not necessary to understand in detail.</h4>

<p>Kelsall, Julia E., and Peter J. Diggle. “Kernel estimation of relative
risk.” Bernoulli 1.1-2 (1995): 3-16.</p>

<h4 id="illustration-of-the-kelsall-diggle-approach-used-to-map-sleeping-sickness-risk">Illustration of the Kelsall Diggle approach used to map sleeping sickness risk</h4>

<p><a href="https://journals.plos.org/plosntds/article?id=10.1371/journal.pntd.0001859">Simarro, Pere P., et al. ”Estimating and mapping the population at risk
of sleeping sickness.” PLoS neglected tropical diseases 6.10 (2012):
e1859.</a></p>

<h2 id="additional-readings">Additional readings</h2>

<h4 id="nice-example-of-kriging-applied-across-space-and-time">Nice example of kriging applied across space and time</h4>

<p><a href="https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0030271">Gething, Peter W., et al. ”A local space–time kriging approach applied
to a national outpatient malaria data set.” Computers &amp; geosciences
33.10 (2007):
1337-1350.</a></p>

<h4 id="additional-example-of-kelsall-diggle-in-action">Additional example of Kelsall Diggle in action</h4>

<p>Di Salvo, Francesca, et al. ”Spatial variation in mortality risk for
hematological malignancies near a petrochemical refinery: A
population-based case-control study.” Environmental research 140 (2015):
641-648.</p>

  </div><a class="u-url" href="/lab-2/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p>This course has been developed over the years by many contributors including Hugh Sturrock, Adam Bennett, Francois Rerolle, Ricardo Andrade, Adam Readhead, David Connell, and Erika Foster. <a href="/about">Read about the team</a>.</p>
      </div>
    </div>

  </div>

</footer></body>

</html>
