<html lang="en_US"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --><title>Week 3 - Spatial variation in risk | Applied Spatial Data Science for Public Health</title><meta name="generator" content="Jekyll v3.9.1" /><meta property="og:title" content="Week 3 - Spatial variation in risk" /><meta name="author" content="UC Berkeley School of Public Health" /><meta property="og:locale" content="en_US" /><meta name="description" content="This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz" /><meta property="og:description" content="This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz" /><link rel="canonical" href="http://localhost:4000/week-3/" /><meta property="og:url" content="http://localhost:4000/week-3/" /><meta property="og:site_name" content="Applied Spatial Data Science for Public Health" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-10-14T00:00:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Week 3 - Spatial variation in risk" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"UC Berkeley School of Public Health"},"dateModified":"2017-10-14T00:00:00-07:00","datePublished":"2017-10-14T00:00:00-07:00","description":"This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz","headline":"Week 3 - Spatial variation in risk","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/week-3/"},"url":"http://localhost:4000/week-3/"}</script> <!-- End Jekyll SEO tag --><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/icons/apple-touch-icon.png?v=qA3OXqyw77"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/icons/favicon-32x32.png?v=qA3OXqyw77"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/icons/favicon-16x16.png?v=qA3OXqyw77"><link rel="manifest" href="/assets/img/icons/manifest.json?v=qA3OXqyw77"><link rel="mask-icon" href="/assets/img/icons/safari-pinned-tab.svg?v=qA3OXqyw77" color="#5bbad5"> <!--[if IE]><link rel="shortcut icon" href="/assets/img/icons/favicon.ico?v=qA3OXqyw77"><![endif]--><link rel="shortcut icon" href="/assets/img/icons/favicon.ico?v=qA3OXqyw77"><meta name="apple-mobile-web-app-title" content="Sleek"><meta name="application-name" content="Sleek"><meta name="msapplication-config" content="/assets/img/icons/browserconfig.xml?v=qA3OXqyw77"><meta name="theme-color" content="#ffffff"><style class="inlineCSS"> h1{color:#313237;margin-top:0;margin-bottom:.5rem}.dark-bg{background-color:#313237}@media (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:last-of-type,.post-card:nth-child(2n+2){margin-right:0}}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figure,main{display:block}figure{margin:1em 40px}a{background-color:transparent;-webkit-text-decoration-skip:objects}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}body{-webkit-overflow-scrolling:touch}*,::after,::before{-webkit-box-sizing:inherit;box-sizing:inherit}.site{display:-webkit-box;display:-ms-flexbox;display:flex;min-height:100vh;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.site__content{-webkit-box-flex:1;-ms-flex:1;flex:1}img{max-width:100%;height:auto;width:auto;vertical-align:middle}figure{margin:0}body{background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:1rem;line-height:1.5;color:#343851;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%}p{margin-top:0;margin-bottom:1.25rem}h1,h2{color:#313237;margin-top:0;margin-bottom:.5rem}a{color:#277cea;text-decoration:none}.blur{background:#fff;filter:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="16" /></filter></svg>#filter');-webkit-filter:blur(1rem);filter:blur(1rem)}.container{padding:0 20px}@media (min-width:0){.container{max-width:auto;margin:0 auto}}@media (min-width:36em){.container{max-width:540px;margin:0 auto}}@media (min-width:48em){.container{max-width:720px;margin:0 auto}}@media (min-width:62em){.container{max-width:960px;margin:0 auto}}@media (min-width:75em){.container{max-width:1170px;margin:0 auto}}.header{background-color:#fff;color:#343851;position:absolute;z-index:4;width:100%;top:0;left:0;will-change:transform;-webkit-transform:translateY(0);transform:translateY(0)}.header a{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.header__logo{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;overflow:hidden;padding:19px 0;margin-right:1.25rem;outline:0;color:#313237}.header__logo .header__logo--container{width:58px}.header__logo .header__logo--container .logo{fill:currentColor}.header__inner{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:3.75em;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.header__links{padding-bottom:.5rem;display:block;position:absolute;top:3.75em;left:0;width:100%;height:auto;visibility:hidden;background:#fff}.header__link{color:#343851;padding:1em 0;border-top:1px solid #ededed}.header__toggle{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:44px;height:100%;background-color:transparent;padding-left:1.25rem}.header__toggle span{display:block;position:relative;margin-top:4px;background-color:#343851;width:100%;height:2px;border-radius:1px}.header__toggle span:first-child{margin-top:0}@media (min-width:62em){.header__toggle{display:none;visibility:hidden}.header__links{position:static;display:-webkit-box;display:-ms-flexbox;display:flex;visibility:visible;width:auto;height:100%}.header__link{position:relative;padding:.938em 0;border:0}.header__link::after{content:"";display:block;position:absolute;left:0;bottom:0;height:3px;width:100%;-webkit-transform:scaleX(0);transform:scaleX(0);background:#277cea}}.post-card{display:block;width:100%;min-height:250px;border-radius:4px;overflow:hidden;background-color:#fff;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.08);box-shadow:0 1px 3px rgba(0,0,0,.08);margin-bottom:5.26316%}@media (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:0}}@media (min-width:75em){.post-card{width:31.25%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:3.125%}}.post-card__thumb{margin:0;background:#fff;position:relative;overflow:hidden}.post-card__thumb::after{content:"";display:block;height:0;width:100%;padding-bottom:56.25%}.post-card__thumb>*{position:absolute;top:0;left:0;width:100%;height:100%;display:block}.post-card__inner{padding:1.875rem 1.25rem .625rem;color:#838c8d}.post-card__header{margin-bottom:.75rem}.post-card__header .post-card__meta{font-size:.875rem}.hero{margin:3.75rem auto 0;min-height:16.25rem;width:100%;position:relative;background-color:#dde5ea;background-repeat:no-repeat;background-position:50%;background-size:cover}@media (min-width:62em){.hero{margin:0 auto;height:36em}}.hero::before{position:absolute;display:block;content:"";top:0;left:0;width:100%;height:100%;background:rgba(52,56,81,.8)}.hero__wrap{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);text-align:center;color:rgba(255,255,255,.8);max-width:40em;z-index:1}.hero__wrap .hero__title{color:#fff}.blog{background-color:#f9f9f9}.post-list{padding-top:2.5em;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}@media (min-width:48em){.hero__wrap .hero__title{font-size:2.625em;line-height:3.125rem}.post-list{padding-top:5em}}</style><link rel="preload" href="/assets/css/main.css" as="style" onload="this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <script type="text/javascript"> /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */ (function(w){"use strict";if(!w.loadCSS){w.loadCSS=function(){}} var rp=loadCSS.relpreload={};rp.support=(function(){var ret;try{ret=w.document.createElement("link").relList.supports("preload")}catch(e){ret=!1} return function(){return ret}})();rp.bindMediaToggle=function(link){var finalMedia=link.media||"all";function enableStylesheet(){link.media=finalMedia} if(link.addEventListener){link.addEventListener("load",enableStylesheet)}else if(link.attachEvent){link.attachEvent("onload",enableStylesheet)} setTimeout(function(){link.rel="stylesheet";link.media="only x"});setTimeout(enableStylesheet,3000)};rp.poly=function(){if(rp.support()){return} var links=w.document.getElementsByTagName("link");for(var i=0;i<links.length;i++){var link=links[i];if(link.rel==="preload"&&link.getAttribute("as")==="style"&&!link.getAttribute("data-loadcss")){link.setAttribute("data-loadcss",!0);rp.bindMediaToggle(link)}}};if(!rp.support()){rp.poly();var run=w.setInterval(rp.poly,500);if(w.addEventListener){w.addEventListener("load",function(){rp.poly();w.clearInterval(run)})}else if(w.attachEvent){w.attachEvent("onload",function(){rp.poly();w.clearInterval(run)})}} if(typeof exports!=="undefined"){exports.loadCSS=loadCSS} else{w.loadCSS=loadCSS}}(typeof global!=="undefined"?global:this)) </script></head><body class="site"><header class="header" itemscope itemtype="http://schema.org/SiteNavigationElement" aria-label="Main navigation"><div class="container"><div class="header__inner"><nav class="header__links"><div class="container header__links-wrapper"> <a class="header__link" href="/" itemprop="url"><span itemprop="name">Home</span></a> <a class="header__link" href="/about" itemprop="url"><span itemprop="name">About</span></a> </a></div></nav><div class="header__toggle"> <span></span> <span></span> <span></span></div></div></div></header><div class="hero lazyload" data-bg="http://localhost:4000/assets/img/posts/rate_density.jpg"><div class="hero__wrap"><h1 class="hero__title">Week 3 - Spatial variation in risk</h1><p class="hero__meta"> <!-- <span> <time>14 Oct 2017</time>&nbsp; </span>--> <span> </span></p></div></div></div><main class="site__content"><div class="container"><article class="post-content" itemprop="articleBody"><p>This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurences of events in a given area). When you load this week’s libraries, it may prompt you to download <a href="https://www.xquartz.org/">XQuartz</a></p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">library</span><span class="p">(</span><span class="n">Metrics</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geoR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">gtools</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">lme4</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">oro.nifti</span><span class="p">)</span></code></pre></figure><p>First load up some obfuscated malaria case-control data from Namibia. This is comprised of latitudes and longitudes of cases and controls.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">CaseControl</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week3/Lab_files/CaseControl.csv"</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">CaseControl</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   household_id       lat     long case
## 1            1 -17.51470 16.05666    1
## 2            2 -17.82175 16.15147    1
## 3            3 -17.78743 15.93465    1
## 4            4 -17.51352 15.83933    1
## 5            5 -17.63668 15.91185    1
## 6            6 -17.64459 16.16105    1
</code></pre></div></div><p>To set ourselves up for further analyses, let’s create objects of just cases and just controls</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">#Create a new object with just the cases, recoded as a number 1</span><span class="w">
</span><span class="n">Cases</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">1</span><span class="p">,]</span><span class="w">

</span><span class="c1">#Create a new object with just the controls, recoded as a number 0</span><span class="w">
</span><span class="n">Controls</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">0</span><span class="p">,]</span></code></pre></figure><p>We are also going to create a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code> of the case-control data</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">CaseControl_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"lat"</span><span class="p">)],</span><span class="w">
                                           </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"household_id"</span><span class="p">,</span><span class="w"> </span><span class="s2">"case"</span><span class="p">)])</span></code></pre></figure><p>And get hold of a boundary file for Namibia</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">NAM_Adm0</span><span class="o">&lt;-</span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s1">'GADM'</span><span class="p">,</span><span class="n">country</span><span class="o">=</span><span class="s1">'NAM'</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="m">0</span><span class="p">)</span></code></pre></figure><p>Let’s plot and see what we have. First, create a color scheme based on the case classification (0 or 1)</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">case_color_scheme</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"red"</span><span class="p">),</span><span class="w"> </span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">)</span></code></pre></figure><p>Then, plot</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">CaseControl_SPDF</span><span class="p">,</span><span class="w"> 
                                              </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">case_color_scheme</span><span class="p">(</span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">),</span><span class="w">
                                              </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-8-1.png" alt="" /><!-- --></p><h2 id="risk-mapping-using-kernel-density">Risk Mapping using Kernel Density</h2><p>To generate a kernel density estimate, we first need to generate point pattern object of points (aka ppp). First, we need to define a window defining the population from which the cases arose</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Nam_Owin</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">xrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">),</span><span class="n">yrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">))</span></code></pre></figure><p>Now we can define the ppp object of the cases</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Cases_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">Cases</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">Cases</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-10-1.png" alt="" /><!-- --></p><p>We can now generate and plot a kernel density estimate of cases</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">)))</span><span class="w">
</span><span class="n">case_density</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">case_density</span><span class="p">)</span><span class="w"> </span><span class="c1"># Units are intensity of points per unit square</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-11-1.png" alt="" /><!-- --></p><p>Its possible to use different bandwidths. The larger the bandwidth, the smoother the density estimate.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.02</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.02"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.1</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.02"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="n">bw.ppl</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Automatically selected bandwidth"</span><span class="p">)</span><span class="w"> </span><span class="c1"># automatic bandwidth selection based on cross-validation</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-12-1.png" alt="" /><!-- --></p><p>If you want to map using leaflet, you have to convert the density object to a rasterLayer with a coordinate reference system</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Create raster</span><span class="w">
</span><span class="n">density_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">bw.ppl</span><span class="p">),</span><span class="w"> </span><span class="n">crs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">))</span><span class="w">

</span><span class="c1"># Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">density_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-13-1.png" alt="" /><!-- --></p><p>But this is just a density of cases, e.g. it doesn’t account for the denominator - the controls. To do this, we can use the kelsall &amp; diggle method, which calculates the ratio of the density estimate of cases:controls</p><p>First we have to add ‘marks’ to the points. Marks are just values associated with each point such as case or control (1/0)</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">CaseControl_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">marks</span><span class="o">=</span><span class="n">as.factor</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="p">))</span></code></pre></figure><p>Now we can use the <code class="language-plaintext highlighter-rouge">relrisk</code> function from the spatstat pakage to look at the risk of being a case relative to the background population. In order to obtain an output of relative risk, we must specify relative = TRUE in the code line (the probability of being a case, relative to probability of being a control). If the ‘relative’ argument is not included in the code line the argument is technically specified as ‘FALSE’ since this is the default and the output is the probability of being a case. You can set sigma (bandwidth), but the default is to use cross-validation to find a common bandwidth to use for cases and controls. See <code class="language-plaintext highlighter-rouge">?bw.relrisk</code> for more details.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">risk_est</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-15-1.png" alt="" /><!-- --></p><h2 id="obtaining-a-relative-risk-of-being-a-case">Obtaining a relative risk of being a case</h2><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">rel_risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">rel_risk_est</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-16-1.png" alt="" /><!-- --></p><p>To plot on a web map, first specify the projection</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">risk_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">risk_est</span><span class="p">,</span><span class="w"> </span><span class="n">crs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">))</span></code></pre></figure><p>Then define a color palette</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">pal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">palette</span><span class="o">=</span><span class="n">tim.colors</span><span class="p">(</span><span class="m">64</span><span class="p">),</span><span class="w"> </span><span class="n">domain</span><span class="o">=</span><span class="n">values</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">),</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span></code></pre></figure><p>Then plot with leaflet</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">(</span><span class="s2">"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pal</span><span class="p">)</span><span class="w"> </span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-19-1.png" alt="" /><!-- --></p><h2 id="interpolation-of-point-prevalence-etc-data">Interpolation of point (prevalence etc.) data</h2><p>First load Ethiopia malaria prevalence data</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">ETH_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv"</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span></code></pre></figure><p>Get the Ethiopia Adm 1 level boundary file using the raster package which provides access to GADM data</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">1</span><span class="p">)</span></code></pre></figure><h2 id="inverse-distance-weighting-idw">Inverse distance weighting (IDW)</h2><p>Inverse distance weighting is one method of interpolation. To perform IDW using the spatstat package, as per kernel density estimates, we have to create a ppp object with the outcome we wish to interpolate as marks. We have to start by setting the observation window. In this case, we are going to use the bounding box around Oromia State from which these data were collected. To set the window for the <code class="language-plaintext highlighter-rouge">ppp</code> function, we need to use the <code class="language-plaintext highlighter-rouge">owin</code> function.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">oromia</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">[</span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">NAME_1</span><span class="o">==</span><span class="s2">"Oromia"</span><span class="p">,]</span><span class="w">
</span><span class="n">oromia_window</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">1</span><span class="p">,],</span><span class="w"> </span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">2</span><span class="p">,])</span></code></pre></figure><p>Then define a ppp of the prevalence data</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">ETH_malaria_data_ppp</span><span class="o">&lt;-</span><span class="n">ppp</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
                         </span><span class="n">marks</span><span class="o">=</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">oromia_window</span><span class="p">)</span></code></pre></figure><p>Set the parameters for displaying multiple plots in one screen and plot different IDW results NB: 1) power represents the power function we want to use 2) ‘at’ can be ‘pixels’ where it generates estimates across a grid of pixels or ‘points’ where it interpolates values at every point using leave-one-out-cross validation</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.2"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.5"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.1"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 2"</span><span class="p">)</span><span class="w"> </span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-24-1.png" alt="" /><!-- --></p><p>To calculate the ‘best’ power to use, you can use cross-validation. This is possible using the argument at=points when running the idw function. There is no off the shelf function (that I know of) to do this, so you have to loop through different power values and find the one that produces the lowest error using cross-validation.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">powers</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">0.05</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">0.05</span><span class="p">)</span><span class="w"> 
</span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">NULL</span><span class="w"> 
</span><span class="k">for</span><span class="p">(</span><span class="n">power</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">powers</span><span class="p">){</span><span class="n">CV_idw</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
  </span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">mse_result</span><span class="p">,</span><span class="w"> </span><span class="n">mse</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="n">CV_idw</span><span class="p">))</span><span class="w"> 
  </span><span class="p">}</span></code></pre></figure><p>See which produced the lowest error</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">optimal_power</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">powers</span><span class="p">[</span><span class="n">which.min</span><span class="p">(</span><span class="n">mse_result</span><span class="p">)]</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">powers</span><span class="p">,</span><span class="w"> </span><span class="n">mse_result</span><span class="p">)</span><span class="w"> </span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-26-1.png" alt="" /><!-- --> Plot observed versus expected with optimal power</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">CV_idw_opt</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">optimal_power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="w"> </span><span class="n">CV_idw_opt</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Predicted prevalence"</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-27-1.png" alt="" /><!-- --></p><p>Plot using leaflet.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># 1. Convert to a raster</span><span class="w">
</span><span class="n">ETH_malaria_data_idw_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="w">
                                     </span><span class="n">crs</span><span class="o">=</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">))</span><span class="w">

</span><span class="c1"># 2. Define a color palette</span><span class="w">
</span><span class="n">colPal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">tim.colors</span><span class="p">(),</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[],</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">

</span><span class="c1"># 3. Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.7</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[])</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-30-1.png" alt="" /><!-- --></p><h2 id="kriging">Kriging</h2><p>We are going to use the GeoR package to perform kriging. First, we have to create a geodata object with the package GeoR. This wants dataframe of x,y and data</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">ETH_malaria_data_geo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr"</span><span class="p">)])</span></code></pre></figure><p>We can plot a summary plot using ther Lowes parameter. The Lowes option gives us lowes curves for the relationship between x and y</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">lowes</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-32-1.png" alt="" /><!-- --></p><p>It’s important to assess whether there is a first order trend in the data before kriging. We can see from the plots of the prevalence against the x and y coordinates that there isn’t really any evidence of such a trend. Were there to be evidence, you can add <code class="language-plaintext highlighter-rouge">trend = 1st</code> or <code class="language-plaintext highlighter-rouge">trend = 2nd</code> to the plot command to see the result after havin regressed prevalence against x and y using a linear and polynomial effect respectively.</p><p>Now generate and plot a variogram. As a rule of thumb, its a good idea to limit variogram estimation to half the maximum interpoint distance</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">MaxDist</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)]))</span><span class="w">  </span><span class="o">/</span><span class="m">2</span><span class="w"> 
</span><span class="n">VarioCloud</span><span class="o">&lt;-</span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">option</span><span class="o">=</span><span class="s2">"cloud"</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">plot</span><span class="p">(</span><span class="n">VarioCloud</span><span class="p">)</span><span class="w"> </span><span class="c1"># all pairwise comparisons</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-33-1.png" alt="" /><!-- --> To make it easier to interpret, we can bin points by distance</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">,</span><span class="w"> </span><span class="n">trend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"2nd"</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-34-1.png" alt="" /><!-- --></p><p>Its possible to change the way the variogram bins are constructed. Just be careful not to have too few pairs of points in any distance class. NB: <code class="language-plaintext highlighter-rouge">uvec</code> agrument provides values to define the variogram binning (ie let’s try bins of 0.2 decimal degrees, about 22 km)</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">,</span><span class="n">uvec</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0.01</span><span class="p">,</span><span class="n">MaxDist</span><span class="p">,</span><span class="m">0.2</span><span class="p">))</span><span class="w"> </span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div><p>Let’s look at the number in each bin</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Vario</span><span class="o">$</span><span class="n">n</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1]  85 432 541 586 692 607 652 661 679 663 736 764 711 692 577 585 594 551 630
## [20] 724
</code></pre></div></div><p>What is the minimum? A rule of thumb is 30 in each bin</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="nf">min</span><span class="p">(</span><span class="n">Vario</span><span class="o">$</span><span class="n">n</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 85
</code></pre></div></div><p>Plot</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-38-1.png" alt="" /><!-- --></p><p>We can now fit variogram model by minimized least sqaures using different covariance models. In this case we are just going to use a ‘spherical’ and ‘exponential’ model.</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">VarioMod_sph</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "sph"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "3.05" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.28256710551259e-05
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">VarioMod_exp</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"exp"</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is exponential 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "exp"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "1.22" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.76112575299845e-05
</code></pre></div></div><p>Plot results</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"blue"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w"> </span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-40-1.png" alt="" /><!-- --></p><p>Get summaries of the fits</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "spherical"
## 
## $spatial.component
##     sigmasq         phi 
## 0.000160867 3.048000000 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 8.043352e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.048
## 
## $sum.of.squares
##        value 
## 2.282567e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 8.043352e-05 1.608670e-04 3.048000e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "sph")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "exponential"
## 
## $spatial.component
##      sigmasq          phi 
## 0.0002281533 1.2192006253 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 3.042044e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.652398
## 
## $sum.of.squares
##        value 
## 2.643998e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 3.042044e-05 2.281533e-04 1.219201e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "exp")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div><p>In this case, the spherical model has a slightly lower sum of squares, suggesting it provides a better fit to the data.</p><p>Now we have a variogram model depicting the covariance between pairs of points as a function of distance between points, we can use it to Krig values at prediction locations. To allow us to compare with IDW, first get grid of points from the IDW example for comparison</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># 1. Create prediction grid</span><span class="w">
</span><span class="n">IDW</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">)</span><span class="w">
</span><span class="n">pred_grid_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">))</span><span class="w">
</span><span class="n">pred_grid_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sort</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">)))</span><span class="w">
</span><span class="n">pred_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="n">pred_grid_y</span><span class="p">)</span><span class="w">

</span><span class="c1"># 2. Now krig to those points</span><span class="w">
</span><span class="n">KrigPred</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige.conv</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="o">=</span><span class="n">pred_grid</span><span class="p">,</span><span class="w">
                       </span><span class="n">krige</span><span class="o">=</span><span class="n">krige.control</span><span class="p">(</span><span class="n">obj.model</span><span class="o">=</span><span class="n">VarioMod_sph</span><span class="p">))</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## krige.conv: model with constant mean
## krige.conv: Kriging performed using global neighbourhood
</code></pre></div></div><p>Visualize predictions</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">image</span><span class="p">(</span><span class="n">KrigPred</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">50</span><span class="p">))</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-44-1.png" alt="" /><!-- --></p><p>If you want to create a raster of your predictions, you can use the <code class="language-plaintext highlighter-rouge">rasterFromXYZ</code> function</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">KrigPred_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterFromXYZ</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="w">
                                 </span><span class="n">y</span><span class="o">=</span><span class="n">pred_grid_y</span><span class="p">,</span><span class="w">
                                 </span><span class="n">z</span><span class="o">=</span><span class="n">KrigPred</span><span class="o">$</span><span class="n">predict</span><span class="p">))</span><span class="w">

</span><span class="n">plot</span><span class="p">(</span><span class="n">KrigPred_raster</span><span class="p">)</span><span class="w">
</span><span class="n">points</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w">
       </span><span class="n">cex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">10</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-45-1.png" alt="" /><!-- --></p><p>Generating cross-validated predictions in straightforward in geoR using the <a href="https://www.rdocumentation.org/packages/geoR/versions/1.8-1/topics/xvalid"><code class="language-plaintext highlighter-rouge">xvlalid</code></a> function. Two types of validation are possible: 1. leaving-on-out cross validation where each data location (all or a subset) is removed in turn and predicted using the remaining locations, for a given model. 2. External validation which can predict to locations outside of the dataset Here we will use the default leave-one-out xvalidation for all points</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">xvalid_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Plot on log odds scale</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">predicted</span><span class="p">,</span><span class="w"> </span><span class="n">asp</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w">
     </span><span class="n">xlab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Cross-validated predicted prevalence"</span><span class="p">)</span><span class="w">
</span><span class="n">abline</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">)</span></code></pre></figure><p><img src="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week3_updatedMar3_files/figure-gfm/unnamed-chunk-46-1.png" alt="" /><!-- --></p><p>You might notice that some of the kriged values are &lt;0. As we are modeling probabilities this can’t be true. In these situations, it is possible to apply a transformation to your data before kriging and then back-transform results. One transformation useful for probabilities is the logit transform (used in logistic regression). The <code class="language-plaintext highlighter-rouge">logit</code> and <code class="language-plaintext highlighter-rouge">inv.logit</code> functions from the package <code class="language-plaintext highlighter-rouge">gtools</code> can be used for this. Note that it doesn’t work if you have 0 values as you can’t log(0). You can add a small amount to avoid this situation. The process would look like this</p><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Add small amount to avoid zeros</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">0.001</span><span class="w">

</span><span class="c1"># Apply logit transform and convert to geodata</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">logit</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="p">)</span><span class="w">
</span><span class="n">ETH_malaria_data_geo_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr_logit"</span><span class="p">)])</span><span class="w">

</span><span class="c1"># Fit (spherical) variogram</span><span class="w">
</span><span class="n">Vario_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">VarioMod_sph_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario_logit</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario_logit, cov.model = "sph"): initial values not provided
## - running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq  kappa
## initial.value "1.16"  "2.45" "0.15" "0.5"
## status        "est"   "est"  "est"  "fix"
## loss value: 448.598010419967
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1"># Get CV kriged predictions</span><span class="w">
</span><span class="n">xvalid_result_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph_logit</span><span class="p">)</span></code></pre></figure><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div><figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">xvalid_result_inv_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">inv.logit</span><span class="p">(</span><span class="n">xvalid_result_logit</span><span class="o">$</span><span class="n">predicted</span><span class="p">)</span></code></pre></figure><h2 id="pop-quiz">Pop quiz</h2><ul><li>How could you compare how well the best fitting IDW performs versus kriging?</li><li>Which appears to be more accurate?</li><li>Can you visualize where predictions from IDW differ to kriging?</li><li>Does inclusion of a trend surface improve kriging estimates?</li></ul><p>Answers <a href="https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/_posts/week_3_cheat_sheet.R">here</a></p><h2 id="key-readings">Key readings</h2><h4 id="good-overview">Good overview</h4><p>Pfeiffer, D., T. P. Robinson, M. Stevenson, K. B. Stevens, D. J. Rogers and A. C. Clements (2008). Spatial analysis in epidemiology, Oxford University Press Oxford. Chapter 6.</p><h4 id="technical-paper-covering-kernel-estimation-of-relative-risk-key-reference-but-not-necessary-to-understand-in-detail">Technical paper covering kernel estimation of relative risk. Key reference but not necessary to understand in detail.</h4><p>Kelsall, Julia E., and Peter J. Diggle. “Kernel estimation of relative risk.” Bernoulli 1.1-2 (1995): 3-16.</p><h4 id="illustration-of-the-kelsall-diggle-approach-used-to-map-sleeping-sickness-risk">Illustration of the Kelsall Diggle approach used to map sleeping sickness risk</h4><p><a href="https://journals.plos.org/plosntds/article?id=10.1371/journal.pntd.0001859">Simarro, Pere P., et al. “Estimating and mapping the population at risk of sleeping sickness.” PLoS neglected tropical diseases 6.10 (2012): e1859.</a></p><h2 id="additional-readings">Additional readings</h2><h4 id="nice-example-of-kriging-applied-across-space-and-time">Nice example of kriging applied across space and time</h4><p><a href="https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0030271">Gething, Peter W., et al. “A local space–time kriging approach applied to a national outpatient malaria data set.” Computers &amp; geosciences 33.10 (2007): 1337-1350.</a></p><h4 id="additional-example-of-kelsall-diggle-in-action">Additional example of Kelsall Diggle in action</h4><p>Di Salvo, Francesca, et al. “Spatial variation in mortality risk for hematological malignancies near a petrochemical refinery: A population-based case-control study.” Environmental research 140 (2015): 641-648.</p></article></div></main><footer class="footer"><div class="container"><nav class="social"></nav><span>&copy; 2022 Applied Spatial Data Science for Public Health. All rights reserved.</span></div></footer><script async src="/assets/js/bundle.js"></script></body></html>
