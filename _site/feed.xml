<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-15T23:34:24-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Applied Spatial Data Science for Public Health</title><subtitle>This site contains the labs for Applied Spatial Data Science for Public Health, a course at UC Berkeley's School of Public Health.</subtitle><entry><title type="html">Week 2 - Manipulating spatial data</title><link href="http://localhost:4000/week-2/" rel="alternate" type="text/html" title="Week 2 - Manipulating spatial data" /><published>2022-02-25T00:00:00-08:00</published><updated>2022-02-25T00:00:00-08:00</updated><id>http://localhost:4000/week-2</id><content type="html" xml:base="http://localhost:4000/week-2/"><![CDATA[<p>In week 1, you got to load up some spatial data and make some pretty
maps. This week, we will be stepping up a gear and learning how to crop
and subset spatial data. We will also be go through the process of
resampling rasters.</p>

<h2 id="learning-outcomes">Learning outcomes</h2>

<p>By the end of this week, you will be able to:</p>

<ul>
  <li>Clip and subset vector and raster data</li>
  <li>Resample rasters</li>
  <li>Relate spatial data</li>
</ul>

<p>Load the necessary libraries for this week</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgdal</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geosphere</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgeos</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">wesanderson</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>First we are going to subset some spatial (polygon) data. For this
exersize, we are going to use the admin 1 boundaries for Ethiopia we
used in week 1. As a reminder, we can load these in from a local
shapefile using the readOGR function, or we can use the handy <code class="language-plaintext highlighter-rouge">getData</code>
function from the <code class="language-plaintext highlighter-rouge">raster</code> package to access GADM data.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>You can subset a SpatialPolygonsDataFrame just like a data frame. Let’s
subset the data first by row/polygon</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1_cropped</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">[</span><span class="m">1</span><span class="p">,]</span><span class="w">

</span><span class="c1"># Get a summary of the cropped data</span><span class="w">
</span><span class="n">ETH_Adm_1_cropped</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPolygonsDataFrame 
## features    : 1 
## extent      : 38.6394, 38.90624, 8.833486, 9.098195  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 10
## names       : GID_0,   NAME_0,   GID_1,      NAME_1,                                     VARNAME_1, NL_NAME_1,    TYPE_1, ENGTYPE_1, CC_1, HASC_1 
## value       :   ETH, Ethiopia, ETH.1_1, Addis Abeba, Āddīs Ābaba|Addis Ababa|Adis-Abeba|Ādīs Ābeba,        NA, Astedader,      City,   14,  ET.AA
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot over the top of the full dataset</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_Adm_1_cropped</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">ETH_Adm_1_cropped</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">,</span><span class="w"> </span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-3-1.png" alt="" /></p>

<p>You can also subset by name. For example, if we wanted to extract the
polygon representing the boundary of the province “Amhara”</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1_Amhara</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">subset</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">NAME_1</span><span class="o">==</span><span class="s2">"Amhara"</span><span class="p">)</span><span class="w"> </span><span class="c1">#OR ETH_Adm_1[ETH_Adm_1$NAME_1=="Amhara",] will also work</span><span class="w">
</span><span class="n">ETH_Adm_1_Amhara</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPolygonsDataFrame 
## features    : 1 
## extent      : 35.25711, 40.21244, 8.714812, 13.7687  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 10
## names       : GID_0,   NAME_0,   GID_1, NAME_1, VARNAME_1, NL_NAME_1, TYPE_1, ENGTYPE_1, CC_1, HASC_1 
## value       :   ETH, Ethiopia, ETH.3_1, Amhara,     Amara,        NA,  Kilil,     State,   03,  ET.AM
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Plot the result</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">ETH_Adm_1_Amhara</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-4-1.png" alt="" /> ### Pop quiz * How would
you plot all provinces except Amhara? * Try plotting all province using
leaflet, with Amhara colored red and all others colored orange.</p>

<h2 id="spatial-overlays">Spatial overlays</h2>

<p>Often, we have point and polygon data and wish to relate them. For
example, we might want to summarize point data over regions. To
illustrate this, we are going to use the Ethiopia malaria point
prevalence data and aggregate that to provincial level to get a
provincial level estimate of prevalence.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get the point prevalence data from the GitHub repo</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/mal_data_eth_2009_no_dups.csv"</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">

</span><span class="c1"># Convert to a SPDF</span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w">
                                      </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"examined"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pf_pos"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pf_pr"</span><span class="p">)],</span><span class="w">
                                      </span><span class="n">proj4string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CRS</span><span class="p">(</span><span class="s2">"+init=epsg:4326"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>To identify the Province each point lies within you can use the <code class="language-plaintext highlighter-rouge">over</code>
function from the <code class="language-plaintext highlighter-rouge">sp</code> package</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETH_Adm_1_per_point &lt;- over(ETH_malaria_data_SPDF, ETH_Adm_1)
  Error in .local(x, y, returnList, fn, ...) : identicalCRS(x, y) is not TRUE
</code></pre></div></div>

<p>This throws an error, because <code class="language-plaintext highlighter-rouge">ETH_malaria_data_SPDF</code> and <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code> do
not have exactly the same coordinate reference system (CRS). Let’s take
a look</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">crs</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Coordinate Reference System:
## Deprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs 
## WKT2 2019 representation:
## GEOGCRS["unknown",
##     DATUM["World Geodetic System 1984",
##         ELLIPSOID["WGS 84",6378137,298.257223563,
##             LENGTHUNIT["metre",1]],
##         ID["EPSG",6326]],
##     PRIMEM["Greenwich",0,
##         ANGLEUNIT["degree",0.0174532925199433],
##         ID["EPSG",8901]],
##     CS[ellipsoidal,2],
##         AXIS["longitude",east,
##             ORDER[1],
##             ANGLEUNIT["degree",0.0174532925199433,
##                 ID["EPSG",9122]]],
##         AXIS["latitude",north,
##             ORDER[2],
##             ANGLEUNIT["degree",0.0174532925199433,
##                 ID["EPSG",9122]]]]
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">crs</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Coordinate Reference System:
## Deprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs 
## WKT2 2019 representation:
## GEOGCRS["unknown",
##     DATUM["World Geodetic System 1984",
##         ELLIPSOID["WGS 84",6378137,298.257223563,
##             LENGTHUNIT["metre",1]],
##         ID["EPSG",6326]],
##     PRIMEM["Greenwich",0,
##         ANGLEUNIT["degree",0.0174532925199433],
##         ID["EPSG",8901]],
##     CS[ellipsoidal,2],
##         AXIS["longitude",east,
##             ORDER[1],
##             ANGLEUNIT["degree",0.0174532925199433,
##                 ID["EPSG",9122]]],
##         AXIS["latitude",north,
##             ORDER[2],
##             ANGLEUNIT["degree",0.0174532925199433,
##                 ID["EPSG",9122]]]]
</code></pre></div></div>

<p>To reproject to the same CRS, you can use the <code class="language-plaintext highlighter-rouge">spTransform</code> function
from the <code class="language-plaintext highlighter-rouge">sp</code> package</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">spTransform</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">))</span><span class="w">

</span><span class="c1"># Check the new;y projected object</span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPointsDataFrame 
## features    : 203 
## extent      : 34.5418, 42.4915, 3.8966, 9.9551  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 3
## names       : examined, pf_pos,       pf_pr 
## min values  :       37,      0,           0 
## max values  :      221,     14, 0.127272727
</code></pre></div></div>

<p>Now we can re-run the over command</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1_per_point</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">over</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This gives us a table where each row represents a point from
<code class="language-plaintext highlighter-rouge">ETH_malaria_data_SPDF</code> and columns represent the data from <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code>.
Let’s take a look</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span><span class="p">(</span><span class="n">ETH_Adm_1_per_point</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   GID_0   NAME_0   GID_1 NAME_1 VARNAME_1 NL_NAME_1 TYPE_1 ENGTYPE_1 CC_1
## 1   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
## 2   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
## 3   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
## 4   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
## 5   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
## 6   ETH Ethiopia ETH.8_1 Oromia   Oromiya      &lt;NA&gt;  Kilil     State   04
##   HASC_1
## 1  ET.OR
## 2  ET.OR
## 3  ET.OR
## 4  ET.OR
## 5  ET.OR
## 6  ET.OR
</code></pre></div></div>

<p>Now we can use this to calculate admin unit specific statistics. We
might be interested in the number of sites per admin unit. To get that,
we could just create a frequency table</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">table</span><span class="p">(</span><span class="n">ETH_Adm_1_per_point</span><span class="o">$</span><span class="n">NAME_1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Benshangul-Gumaz  Gambela Peoples           Oromia 
##                1                1              201
</code></pre></div></div>

<p>Or we can use the <code class="language-plaintext highlighter-rouge">tapply</code> function for more complex calculations.
<code class="language-plaintext highlighter-rouge">tapply</code> allows us to apply a function across groups. Let’s look at the
number examined per admin unit</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nex_per_Adm1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tapply</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">examined</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_Adm_1_per_point</span><span class="o">$</span><span class="n">NAME_1</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="n">Nex_per_Adm1</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Benshangul-Gumaz  Gambela Peoples           Oromia 
##              109              108            24350
</code></pre></div></div>

<p>Now let’s get the number of positives by admin unit</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Npos_per_Adm1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tapply</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">pf_pos</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_Adm_1_per_point</span><span class="o">$</span><span class="n">NAME_1</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="n">Npos_per_Adm1</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Benshangul-Gumaz  Gambela Peoples           Oromia 
##                1                0               78
</code></pre></div></div>

<p>From these numbers, we can calculate the prevalence per province</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prev_per_Adm1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Npos_per_Adm1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Nex_per_Adm1</span><span class="w">
</span><span class="n">prev_per_Adm1</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Benshangul-Gumaz  Gambela Peoples           Oromia 
##      0.009174312      0.000000000      0.003203285
</code></pre></div></div>

<p>If you want to merge these provincial prevalence estimates back into the
province object <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code> it is best practice to create a new table of
prevalence by provice with unique ID for each province. That unique ID
can be used to relate and merge the data with <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code>.</p>

<p>First convert your prev_per_Adm1 vector into a dataframe with an ID
column</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prev_per_Adm1_df</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">NAME_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="n">prev_per_Adm1</span><span class="p">),</span><span class="w">
                               </span><span class="n">prevalence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_per_Adm1</span><span class="p">,</span><span class="w">
                               </span><span class="n">row.names</span><span class="o">=</span><span class="kc">NULL</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now merge this with the <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code> data frame</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">merge</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">,</span><span class="w"> </span><span class="n">prev_per_Adm1_df</span><span class="p">,</span><span class="w">
                  </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"NAME_1"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>You can now see that the additional <code class="language-plaintext highlighter-rouge">prevalence</code> field has been added</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##             NAME_1 GID_0   NAME_0   GID_1
## 1      Addis Abeba   ETH Ethiopia ETH.1_1
## 2             Afar   ETH Ethiopia ETH.2_1
## 3           Amhara   ETH Ethiopia ETH.3_1
## 4 Benshangul-Gumaz   ETH Ethiopia ETH.4_1
## 5        Dire Dawa   ETH Ethiopia ETH.5_1
## 6  Gambela Peoples   ETH Ethiopia ETH.6_1
##                                       VARNAME_1 NL_NAME_1    TYPE_1 ENGTYPE_1
## 1 Āddīs Ābaba|Addis Ababa|Adis-Abeba|Ādīs Ābeba      &lt;NA&gt; Astedader      City
## 2                                                    &lt;NA&gt;     Kilil     State
## 3                                         Amara      &lt;NA&gt;     Kilil     State
## 4                              Beneshangul Gumu      &lt;NA&gt;     Kilil     State
## 5                                                    &lt;NA&gt; Astedader      City
## 6                                       Gambela      &lt;NA&gt;     Kilil     State
##   CC_1 HASC_1  prevalence
## 1   14  ET.AA          NA
## 2   02  ET.AF          NA
## 3   03  ET.AM          NA
## 4   06  ET.BE 0.009174312
## 5   15  ET.DD          NA
## 6   12  ET.GA 0.000000000
</code></pre></div></div>

<p>We can now plot province colored by prevalence. Let’s use the leaflet
package</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># First define a color palette based on prevalence</span><span class="w">
</span><span class="n">colorPal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">wes_palette</span><span class="p">(</span><span class="s2">"Zissou1"</span><span class="p">)[</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">],</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">prevalence</span><span class="p">)</span><span class="w">

</span><span class="c1"># Plot with leaflet</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addProviderTiles</span><span class="p">(</span><span class="s2">"CartoDB.Positron"</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addPolygons</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ETH_Adm_1</span><span class="p">,</span><span class="w"> 
                                         </span><span class="n">col</span><span class="o">=</span><span class="n">colorPal</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">prevalence</span><span class="p">),</span><span class="w">
                                         </span><span class="n">fillOpacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
                                         </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorPal</span><span class="p">,</span><span class="w"> 
                                         </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">prevalence</span><span class="p">,</span><span class="w">
                                         </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Prevalence"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-17-1.png" alt="" /></p>

<h3 id="notes-on-table-joins">Notes on table joins</h3>

<p>In this example, we joined the table of prevalence values for each State
using the common <code class="language-plaintext highlighter-rouge">NAME_1</code> field Often, however, when you are joining a
table of data to some spatial data, they are from different sources and
the common field on which to match rows can be formatted differently.
For example if you were merging a table of state level data for the USA
using the state name, your table might have an entry for <code class="language-plaintext highlighter-rouge">California</code>
which would not match with your spatial data if it has <code class="language-plaintext highlighter-rouge">california</code> as
the corresponding entry. It is always preferable to use ID codes over
names for matching as these are often less variable. If you do have to
use a character string such as name, the following functions are useful
ways to reformat characters to make sure they match:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">substr</code> - this allows you to extract substrings, for example
<code class="language-plaintext highlighter-rouge">substr("Cali", 1,2)</code> extracts the first to second characters and
would give you back <code class="language-plaintext highlighter-rouge">Ca</code></li>
  <li><code class="language-plaintext highlighter-rouge">tolower</code> - converts all characters to lower case. <code class="language-plaintext highlighter-rouge">toupper</code> is the
reverse.</li>
  <li><code class="language-plaintext highlighter-rouge">gsub</code> - allows you to replace characters. For example
<code class="language-plaintext highlighter-rouge">gsub(" ", "-", "CA USA")</code> would replace any whitespace with <code class="language-plaintext highlighter-rouge">-</code>,
i.e. in this example it would return <code class="language-plaintext highlighter-rouge">CA-USA</code>.</li>
</ul>

<p><a href="https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/code/table_joins.R">Go
here</a>
for a worked example of table joins in R.</p>

<h3 id="pop-quiz">Pop quiz</h3>

<ul>
  <li>Try generating the same plot using a different color palette.</li>
  <li>How would you plot only the provinces for which you have prevalence
estimates?</li>
</ul>

<h1 id="manipulating-raster-data">Manipulating raster data</h1>

<p>You’ve now seen how to subset polygons and relate point and polygon
data. Now we are going to look at basic manipulations of raster data. We
are going to load 2 raster file, elevation and land use for Ethiopia.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get elevation using the getData function from the raster package</span><span class="w">
</span><span class="n">ETH_elev</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"alt"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-18-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Land use (# For information on land use classifications see http://due.esrin.esa.int/files/GLOBCOVER2009_Validation_Report_2.2.pdf)</span><span class="w">
</span><span class="n">ETH_land_use</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="s2">"https://github.com/phw272c/phw272c.github.io/raw/master/data/ETH_land_use.tif"</span><span class="p">)</span><span class="w">
</span><span class="n">ETH_land_use</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class      : RasterLayer 
## dimensions : 4121, 5384, 22187464  (nrow, ncol, ncell)
## resolution : 0.002777778, 0.002777778  (x, y)
## extent     : 33.00139, 47.95694, 3.398611, 14.84583  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : ETH_land_use.tif 
## names      : ETH_land_use 
## values     : 11, 210  (min, max)
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Plot the land use raster</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_land_use</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-18-2.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># For a break down of the classes in Ethiopia aka how often each land use type occurs</span><span class="w">
</span><span class="c1">#(Note: this is just the number of pixels per land use type - NOT acres)</span><span class="w">
</span><span class="n">table</span><span class="p">(</span><span class="n">ETH_land_use</span><span class="p">[])</span><span class="w"> 
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##      11      14      20      30      40      60      90     110     120     130 
##  105074  336324 2451623 2223305  129786  813227       8 5254463  580793 1900890 
##     140     150     160     170     180     190     200     210 
## 1403832 1998099    6765      18   26026    6375 2947145 2003711
</code></pre></div></div>

<h2 id="resampling-rasters">Resampling rasters</h2>

<p>Its good practice to resample rasters to the same extent and resolution
(i.e. same grid). This makes it easier to deal with later and to relate
rasters to each other. The <code class="language-plaintext highlighter-rouge">resample</code> command in the <code class="language-plaintext highlighter-rouge">raster</code> package
makes this process easy. Here we are going to resample our land use
raster, but for a deeper dive on resampling rasters of different data
types, <a href="https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/code/raster_resampling.R">go
here</a>.
The default method is bilinear interpolation, which doesn’t make sense
for our categorical variable, so we should use the nearest neighbour
function ‘ngb’</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Takes a little time to run..</span><span class="w">
</span><span class="n">ETH_land_use_resampled</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">resample</span><span class="p">(</span><span class="n">ETH_land_use</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_elev</span><span class="p">,</span><span class="w"> </span><span class="n">method</span><span class="o">=</span><span class="s2">"ngb"</span><span class="p">)</span><span class="w"> 

</span><span class="c1"># Get summaries of both raster objects to check resolution and extent</span><span class="w">
</span><span class="c1"># and to see whether resampled values look right</span><span class="w">
</span><span class="n">ETH_land_use_resampled</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class      : RasterLayer 
## dimensions : 1416, 1824, 2582784  (nrow, ncol, ncell)
## resolution : 0.008333333, 0.008333333  (x, y)
## extent     : 32.9, 48.1, 3.2, 15  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : memory
## names      : ETH_land_use 
## values     : 11, 210  (min, max)
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_elev</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class      : RasterLayer 
## dimensions : 1416, 1824, 2582784  (nrow, ncol, ncell)
## resolution : 0.008333333, 0.008333333  (x, y)
## extent     : 32.9, 48.1, 3.2, 15  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : ETH_msk_alt.grd 
## names      : ETH_msk_alt 
## values     : -189, 4420  (min, max)
</code></pre></div></div>

<h2 id="manipulating-rasters">Manipulating rasters</h2>

<p>It is often the case that we want to change the resolution of a raster
for analysis. For example, for computational reasons we might want to
work at a coarser resolution. First, let’s check the resolution</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">res</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">)</span><span class="w"> </span><span class="c1"># in decimal degrees. 1 dd roughly 111km at the equator</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 0.008333333 0.008333333
</code></pre></div></div>

<p>Let’s aggregate (make lower resolution) by a factor of 10</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_elev_low_res</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">aggregate</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">,</span><span class="w"> </span><span class="n">fact</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="c1"># by default, calculates mean</span><span class="w">
</span><span class="n">res</span><span class="p">(</span><span class="n">ETH_elev_low_res</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 0.08333333 0.08333333
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">ETH_elev_low_res</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-21-1.png" alt="" /></p>

<p>You can change the values of the pixels easily. For example, if you want
to change the <code class="language-plaintext highlighter-rouge">ETH_elev</code> raster from its native meters to feet, you can
mulitply by 3.28</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_elev_feet</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_elev</span><span class="o">*</span><span class="m">3.28</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_elev_feet</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-22-1.png" alt="" /></p>

<p>Similarly, you can categorize raster values</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_elev_categorized</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cut</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_elev_categorized</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-23-1.png" alt="" /></p>

<p>If a raster is the same resolution and extent, you can perform joint
operations on them, for example subtract values of one from another</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_elev</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ETH_land_use_resampled</span><span class="w"> </span><span class="c1"># Meaningless! Just for illustrative purposes..</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">new_raster</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-24-1.png" alt="" /></p>

<h1 id="extracting-data-from-rasters">Extracting data from rasters</h1>

<p>Now let’s extract values of elevation at each survey point. You can use
the <code class="language-plaintext highlighter-rouge">extract</code> function from the raster package and insert the extracted
values as a new field on <code class="language-plaintext highlighter-rouge">ETH_malaria_data_SPDF</code></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">elev</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_malaria_data_SPDF</span><span class="p">)</span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="w"> </span><span class="c1"># now has 3 variables</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPointsDataFrame 
## features    : 203 
## extent      : 34.5418, 42.4915, 3.8966, 9.9551  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 4
## names       : examined, pf_pos,       pf_pr, elev 
## min values  :       37,      0,           0,  817 
## max values  :      221,     14, 0.127272727, 2451
</code></pre></div></div>

<p>You can also extract values using polygons e.g to get admin 1 level
elevations. You just have to define a function to apply, otherwise you
get all the pixel values per polygon. For very large rasters, check out
the <code class="language-plaintext highlighter-rouge">velox</code> package.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">elev</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">extract</span><span class="p">(</span><span class="n">ETH_elev</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">,</span><span class="w"> </span><span class="n">fun</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span><span class="w"> </span><span class="n">na.rm</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="c1"># takes a little longer..</span><span class="w">
</span></code></pre></div></div>

<h1 id="exploratory-spatial-analysis">Exploratory spatial analysis</h1>

<p>We can now have a quick look at the relationship between prevalence and
elevation. First generate a prevalence variable</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">prevalence</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">pf_pos</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">examined</span><span class="w">
</span></code></pre></div></div>

<p>Now you can plot the relationship between prevalence and elevation</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ggplot</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">geom_point</span><span class="p">(</span><span class="n">aes</span><span class="p">(</span><span class="n">elev</span><span class="p">,</span><span class="w"> </span><span class="n">prevalence</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-28-1.png" alt="" /></p>

<p>You might also be interested in distances to/from other features
(e.g. health facilities, water). Here we are going to load up a
waterbody layer (obtained via <a href="http://www.diva-gis.org/Data">http://www.diva-gis.org/Data</a>) and
calculate distance from each point. In this case, the file is in GeoJSON
format instead of Shapefile. <code class="language-plaintext highlighter-rouge">readOGR</code> is able to handle GeoJSON easily.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">waterbodies</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">readOGR</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/ETH_waterbodies.geojson"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## OGR data source with driver: GeoJSON 
## Source: "https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/ETH_waterbodies.geojson", layer: "ETH_waterbodies"
## with 380 features
## It has 5 fields
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">waterbodies</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPolygonsDataFrame 
## features    : 380 
## extent      : 33.00001, 46.80059, 4.232061, 14.55  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 5
## names       : ISO,  COUNTRY,                 F_CODE_DES,                             HYC_DESCRI,                  NAME 
## min values  : ETH, Ethiopia,               Inland Water, Non-Perennial/Intermittent/Fluctuating, ABAY WENZ (BLUE NILE) 
## max values  : ETH, Ethiopia, Land Subject to Inundation,                    Perennial/Permanent,           ZIWAY HAYK'
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">waterbodies</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-2/unnamed-chunk-29-1.png" alt="" /></p>

<p>The goesphere package has some nice functions such as <code class="language-plaintext highlighter-rouge">dist2Line</code> which
calculates distance in meters from spatial data recorded using decimal
degrees. Warning: takes a little while to compute</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist_to_water</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dist2Line</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">waterbodies</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>This produces a matrix, where each row represents each point in
<code class="language-plaintext highlighter-rouge">ETH_malaria_data_SPDF</code> and the first column is the distance in meters
to the nearest waterbody</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span><span class="p">(</span><span class="n">dist_to_water</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##       distance      lon      lat  ID
## [1,] 116153.32 38.03253 6.426888 363
## [2,] 163802.37 38.56778 7.082849 358
## [3,] 137683.25 40.65231 8.808335 238
## [4,] 173427.48 37.62588 5.794201 367
## [5,]  40482.23 37.00735 4.811708 365
## [6,] 163677.02 38.56340 7.075962 358
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Can add to your data frame by extracting the first column</span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">dist_to_water</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">dist_to_water</span><span class="p">[,</span><span class="m">1</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>If the objects you are interested in calucating distance to are points
as opposed to polygons/lines (as above) you first have to calculate the
distance to every point and then identify the minimum. For example,
imagine waterbodies data was only available as a point dataset (we can
fake this by calculating the centroid of each polygon)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">waterbodies_points</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">gCentroid</span><span class="p">(</span><span class="n">waterbodies</span><span class="p">,</span><span class="w"> </span><span class="n">byid</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Now calucate a distance matrix showing distances between each
observation and each waterbody point. the <code class="language-plaintext highlighter-rouge">distm</code> function creates a
distance matrix between every pair of data points and waterbody points
in meters.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dist_matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">distm</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">waterbodies_points</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then use the apply function to apply the ‘minimum’ function to each row
(as each row represents the distance of every waterbody point from our
first observation)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">dist_to_water_point</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The alternative, much faster, but potentially less accurate method to
‘distm’, is to use the nn2 function from the RANN package. This allows
you to calculate the nearest point from each observation and then you
can use the ‘distGeo’ function from the ‘geosphere’ package to calculate
the distance in meters. The reason this could be inaccurate, is that the
nearest point in decimal degrees might not be the nearest in meters as
degrees are not a good measure of distance. In most cases, you are
probably OK.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">RANN</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geosphere</span><span class="p">)</span><span class="w">

</span><span class="c1"># Get the index of the waterbody points that are nearest to each observation</span><span class="w">
</span><span class="n">nn</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">nn2</span><span class="p">(</span><span class="n">waterbodies_points</span><span class="o">@</span><span class="n">coords</span><span class="p">,</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">@</span><span class="n">coords</span><span class="p">,</span><span class="w"> 
          </span><span class="n">k</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w">
          
</span><span class="c1"># Calculate the distance in meters between each observation and its nearest waterbody point   </span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">dist_to_water_point</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">distGeo</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">@</span><span class="n">coords</span><span class="p">,</span><span class="w">
        </span><span class="n">waterbodies_points</span><span class="o">@</span><span class="n">coords</span><span class="p">[</span><span class="n">nn</span><span class="o">$</span><span class="n">nn.idx</span><span class="p">,])</span><span class="w">
</span></code></pre></div></div>

<h2 id="useful-resources">Useful resources</h2>

<ul>
  <li>
    <p>The <a href="https://rspatial.org/raster/pkg/1-introduction.html">raster package
vignette</a> is
extremely useful</p>
  </li>
  <li>
    <p>If you are bumping into speed issues extracting/summarizing raster
data, have a look at the <a href="https://isciences.gitlab.io/exactextractr/">exactextractr
package</a></p>
  </li>
</ul>

<h2 id="key-readings">Key readings</h2>

<p>This week is all about practice. Instead of working through journal
articles, have a play with your data and get to know how the functions
work.</p>

<h2 id="pop-quiz-answers">Pop quiz answers</h2>

<p>Can <a href="https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/code/cheat_sheet_week2.R">be found
here</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[In week 1, you got to load up some spatial data and make some pretty maps. This week, we will be stepping up a gear and learning how to crop and subset spatial data. We will also be go through the process of resampling rasters.]]></summary></entry><entry><title type="html">Week 3 - Spatial variation in risk</title><link href="http://localhost:4000/week-3/" rel="alternate" type="text/html" title="Week 3 - Spatial variation in risk" /><published>2022-02-25T00:00:00-08:00</published><updated>2022-02-25T00:00:00-08:00</updated><id>http://localhost:4000/week-3</id><content type="html" xml:base="http://localhost:4000/week-3/"><![CDATA[<p>This week we are going to explore methods to understand and predict risk
across space from point data. These may be point level data
(i.e. measurements of something of interest at particular points) or
point process data (i.e. occurences of events in a given area). When you
load this week’s libraries, it may prompt you to download
<a href="https://www.xquartz.org/">XQuartz</a></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">Metrics</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geoR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">gtools</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">lme4</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">oro.nifti</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>First load up some obfuscated malaria case-control data from Namibia.
This is comprised of latitudes and longitudes of cases and controls.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/CaseControl.csv"</span><span class="p">)</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">CaseControl</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   household_id       lat     long case
## 1            1 -17.51470 16.05666    1
## 2            2 -17.82175 16.15147    1
## 3            3 -17.78743 15.93465    1
## 4            4 -17.51352 15.83933    1
## 5            5 -17.63668 15.91185    1
## 6            6 -17.64459 16.16105    1
</code></pre></div></div>

<p>To set ourselves up for further analyses, let’s create objects of just
cases and just controls</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#Create a new object with just the cases, recoded as a number 1</span><span class="w">
</span><span class="n">Cases</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">1</span><span class="p">,]</span><span class="w">

</span><span class="c1">#Create a new object with just the controls, recoded as a number 0</span><span class="w">
</span><span class="n">Controls</span><span class="o">&lt;-</span><span class="n">CaseControl</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">0</span><span class="p">,]</span><span class="w">
</span></code></pre></div></div>

<p>We are also going to create a <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrame</code> of the
case-control data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"lat"</span><span class="p">)],</span><span class="w">
                                           </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"household_id"</span><span class="p">,</span><span class="w"> </span><span class="s2">"case"</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>And get hold of a boundary file for Namibia</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NAM_Adm0</span><span class="o">&lt;-</span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s1">'GADM'</span><span class="p">,</span><span class="n">country</span><span class="o">=</span><span class="s1">'NAM'</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="m">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let’s plot and see what we have. First, create a color scheme based on
the case classification (0 or 1)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case_color_scheme</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"red"</span><span class="p">),</span><span class="w"> </span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then, plot</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">CaseControl_SPDF</span><span class="p">,</span><span class="w"> 
                                              </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">case_color_scheme</span><span class="p">(</span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">),</span><span class="w">
                                              </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-8-1.png" alt="" /></p>

<h2 id="risk-mapping-using-kernel-density">Risk Mapping using Kernel Density</h2>

<p>To generate a kernel density estimate, we first need to generate point
pattern object of points (aka ppp). First, we need to define a window
defining the population from which the cases arose</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Nam_Owin</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">xrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">),</span><span class="n">yrange</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now we can define the ppp object of the cases</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Cases_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">Cases</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">Cases</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-10-1.png" alt="" /></p>

<p>We can now generate and plot a kernel density estimate of cases</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">)))</span><span class="w">
</span><span class="n">case_density</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">case_density</span><span class="p">)</span><span class="w"> </span><span class="c1"># Units are intensity of points per unit square</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-11-1.png" alt="" /></p>

<p>Its possible to use different bandwidths. The larger the bandwidth, the
smoother the density estimate.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">mar</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.02</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.02"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="m">0.1</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Bandwidth 0.02"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="n">bw.ppl</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Automatically selected bandwidth"</span><span class="p">)</span><span class="w"> </span><span class="c1"># automatic bandwidth selection based on cross-validation</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-12-1.png" alt="" /></p>

<p>If you want to map using leaflet, you have to convert the density object
to a rasterLayer with a coordinate reference system</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create raster</span><span class="w">
</span><span class="n">density_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">density</span><span class="p">(</span><span class="n">Cases_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">bw.ppl</span><span class="p">))</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">density_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">)</span><span class="w">

</span><span class="c1"># Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">density_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-13-1.png" alt="" /></p>

<p>But this is just a density of cases, e.g. it doesn’t account for the
denominator - the controls. To do this, we can use the kelsall &amp; diggle
method, which calculates the ratio of the density estimate of
cases:controls</p>

<p>First we have to add ‘marks’ to the points. Marks are just values
associated with each point such as case or control (1/0)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl_ppp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ppp</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nam_Owin</span><span class="p">,</span><span class="w"> 
                       </span><span class="n">marks</span><span class="o">=</span><span class="n">as.factor</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now we can use the <code class="language-plaintext highlighter-rouge">relrisk</code> function from the spatstat pakage to look
at the risk of being a case relative to the background population. In
order to obtain an output of relative risk, we must specify relative =
TRUE in the code line (the probability of being a case, relative to
probability of being a control). If the ‘relative’ argument is not
included in the code line the argument is technically specified as
‘FALSE’ since this is the default and the output is the probability of
being a case. You can set sigma (bandwidth), but the default is to use
cross-validation to find a common bandwidth to use for cases and
controls. See <code class="language-plaintext highlighter-rouge">?bw.relrisk</code> for more details.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">risk_est</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-15-1.png" alt="" /></p>

<h2 id="obtaining-a-relative-risk-of-being-a-case">Obtaining a relative risk of being a case</h2>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mar</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">4</span><span class="p">))</span><span class="w">
</span><span class="n">rel_risk_est</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">  </span><span class="n">relrisk</span><span class="p">(</span><span class="n">CaseControl_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">relative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">rel_risk_est</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-16-1.png" alt="" /></p>

<p>To plot on a web map, first specify the projection</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">risk_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">risk_est</span><span class="p">)</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">NAM_Adm0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then define a color palette</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">palette</span><span class="o">=</span><span class="n">tim.colors</span><span class="p">(</span><span class="m">64</span><span class="p">),</span><span class="w"> </span><span class="n">domain</span><span class="o">=</span><span class="n">values</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">),</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Then plot with leaflet</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">(</span><span class="s2">"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">risk_raster</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.6</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pal</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-19-1.png" alt="" /></p>

<h2 id="interpolation-of-point-prevalence-etc-data">Interpolation of point (prevalence etc.) data</h2>

<p>First load Ethiopia malaria prevalence data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/mal_data_eth_2009_no_dups.csv"</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Get the Ethiopia Adm 1 level boundary file using the raster package
which provides access to GADM data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="inverse-distance-weighting-idw">Inverse distance weighting (IDW)</h2>

<p>Inverse distance weighting is one method of interpolation. To perform
IDW using the spatstat package, as per kernel density estimates, we have
to create a ppp object with the outcome we wish to interpolate as marks.
We have to start by setting the observation window. In this case, we are
going to use the bounding box around Oromia State from which these data
were collected. To set the window for the <code class="language-plaintext highlighter-rouge">ppp</code> function, we need to use
the <code class="language-plaintext highlighter-rouge">owin</code> function.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oromia</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_Adm_1</span><span class="p">[</span><span class="n">ETH_Adm_1</span><span class="o">$</span><span class="n">NAME_1</span><span class="o">==</span><span class="s2">"Oromia"</span><span class="p">,]</span><span class="w">
</span><span class="n">oromia_window</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">owin</span><span class="p">(</span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">1</span><span class="p">,],</span><span class="w"> </span><span class="n">oromia</span><span class="o">@</span><span class="n">bbox</span><span class="p">[</span><span class="m">2</span><span class="p">,])</span><span class="w">
</span></code></pre></div></div>

<p>Then define a ppp of the prevalence data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_ppp</span><span class="o">&lt;-</span><span class="n">ppp</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
                         </span><span class="n">marks</span><span class="o">=</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">oromia_window</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Set the parameters for displaying multiple plots in one screen and plot
different IDW results NB: 1) power represents the power function we want
to use 2) ‘at’ can be ‘pixels’ where it generates estimates across a
grid of pixels or ‘points’ where it interpolates values at every point
using leave-one-out-cross validation</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.2"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.5</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.5"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 0.1"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">),</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">20</span><span class="p">),</span><span class="w"> </span><span class="n">main</span><span class="o">=</span><span class="s2">"power = 2"</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-24-1.png" alt="" /></p>

<p>To calculate the ‘best’ power to use, you can use cross-validation. This
is possible using the argument at=points when running the idw function.
There is no off the shelf function (that I know of) to do this, so you
have to loop through different power values and find the one that
produces the lowest error using cross-validation.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">powers</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">seq</span><span class="p">(</span><span class="m">0.05</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">0.05</span><span class="p">)</span><span class="w"> 
</span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">NULL</span><span class="w"> 
</span><span class="k">for</span><span class="p">(</span><span class="n">power</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">powers</span><span class="p">){</span><span class="n">CV_idw</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
  </span><span class="n">mse_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">mse_result</span><span class="p">,</span><span class="w"> </span><span class="n">mse</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="n">CV_idw</span><span class="p">))</span><span class="w"> 
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>See which produced the lowest error</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimal_power</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">powers</span><span class="p">[</span><span class="n">which.min</span><span class="p">(</span><span class="n">mse_result</span><span class="p">)]</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">powers</span><span class="p">,</span><span class="w"> </span><span class="n">mse_result</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-26-1.png" alt="" /> Plot observed versus
expected with optimal power</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CV_idw_opt</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="n">optimal_power</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"points"</span><span class="p">)</span><span class="w"> 
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="o">$</span><span class="n">marks</span><span class="p">,</span><span class="w"> </span><span class="n">CV_idw_opt</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Predicted prevalence"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-27-1.png" alt="" /></p>

<p>Plot using leaflet.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Convert to a raster</span><span class="w">
</span><span class="n">ETH_malaria_data_idw_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="p">(</span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> 
                                          </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">))</span><span class="w">
</span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">crs</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">

</span><span class="c1">#2. Define a color palette</span><span class="w">
</span><span class="n">colPal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="n">tim.colors</span><span class="p">(),</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[],</span><span class="w"> </span><span class="n">na.color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">NA</span><span class="p">)</span><span class="w">

</span><span class="c1"># 3. Plot</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addRasterImage</span><span class="p">(</span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">opacity</span><span class="o">=</span><span class="m">0.7</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w">
  </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colPal</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data_idw_raster</span><span class="p">[])</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-28-1.png" alt="" /></p>

<h2 id="kriging">Kriging</h2>

<p>We are going to use the GeoR package to perform kriging. First, we have
to create a geodata object with the package GeoR. This wants dataframe
of x,y and data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_geo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr"</span><span class="p">)])</span><span class="w">
</span></code></pre></div></div>

<p>We can plot a summary plot using ther Lowes parameter. The Lowes option
gives us lowes curves for the relationship between x and y</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">lowes</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-30-1.png" alt="" /></p>

<p>It’s important to assess whether there is a first order trend in the
data before kriging. We can see from the plots of the prevalence against
the x and y coordinates that there isn’t really any evidence of such a
trend. Were there to be evidence, you can add <code class="language-plaintext highlighter-rouge">trend = 1st</code> or
<code class="language-plaintext highlighter-rouge">trend = 2nd</code> to the plot command to see the result after havin
regressed prevalence against x and y using a linear and polynomial
effect respectively.</p>

<p>Now generate and plot a variogram. As a rule of thumb, its a good idea
to limit variogram estimation to half the maximum interpoint distance</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MaxDist</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)]))</span><span class="w">  </span><span class="o">/</span><span class="m">2</span><span class="w"> 
</span><span class="n">VarioCloud</span><span class="o">&lt;-</span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">option</span><span class="o">=</span><span class="s2">"cloud"</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">VarioCloud</span><span class="p">)</span><span class="w"> </span><span class="c1"># all pairwise comparisons</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-31-1.png" alt="" /> To make it easier to
interpret, we can bin points by distance</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">,</span><span class="w"> </span><span class="n">trend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"2nd"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-32-1.png" alt="" /></p>

<p>Its possible to change the way the variogram bins are constructed. Just
be careful not to have too few pairs of points in any distance class.
NB: <code class="language-plaintext highlighter-rouge">uvec</code> agrument provides values to define the variogram binning (ie
let’s try bins of 0.2 decimal degrees, about 22 km)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="n">max.dist</span><span class="o">=</span><span class="n">MaxDist</span><span class="p">,</span><span class="n">uvec</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0.01</span><span class="p">,</span><span class="n">MaxDist</span><span class="p">,</span><span class="m">0.2</span><span class="p">))</span><span class="w"> 
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<p>Let’s look at the number in each bin</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vario</span><span class="o">$</span><span class="n">n</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##  [1]  85 432 541 586 692 607 652 661 679 663 736 764 711 692 577 585 594 551 630
## [20] 724
</code></pre></div></div>

<p>What is the minimum? A rule of thumb is 30 in each bin</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">min</span><span class="p">(</span><span class="n">Vario</span><span class="o">$</span><span class="n">n</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 85
</code></pre></div></div>

<p>Plot</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-36-1.png" alt="" /></p>

<p>We can now fit variogram model by minimized least sqaures using
different covariance models. In this case we are just going to use a
‘spherical’ and ‘exponential’ model.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_sph</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "sph"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "3.05" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.28256710551259e-05
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_exp</span><span class="o">&lt;-</span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"exp"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is exponential 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario, cov.model = "exp"): initial values not provided -
## running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq kappa
## initial.value "0"     "1.22" "0"   "0.5"
## status        "est"   "est"  "est" "fix"
## loss value: 2.76112575299845e-05
</code></pre></div></div>

<p>Plot results</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">,</span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"blue"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">
</span><span class="n">lines</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">,</span><span class="n">lwd</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-38-1.png" alt="" /></p>

<p>Get summaries of the fits</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_sph</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "spherical"
## 
## $spatial.component
##     sigmasq         phi 
## 0.000160867 3.048000000 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 8.043352e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.048
## 
## $sum.of.squares
##        value 
## 2.282567e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 8.043352e-05 1.608670e-04 3.048000e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "sph")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">summary</span><span class="p">(</span><span class="n">VarioMod_exp</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $pmethod
## [1] "WLS (weighted least squares)"
## 
## $cov.model
## [1] "exponential"
## 
## $spatial.component
##      sigmasq          phi 
## 0.0002281533 1.2192006253 
## 
## $spatial.component.extra
## kappa 
##   0.5 
## 
## $nugget.component
##        tausq 
## 3.042044e-05 
## 
## $fix.nugget
## [1] FALSE
## 
## $fix.kappa
## [1] TRUE
## 
## $practicalRange
## [1] 3.652398
## 
## $sum.of.squares
##        value 
## 2.643998e-05 
## 
## $estimated.pars
##        tausq      sigmasq          phi 
## 3.042044e-05 2.281533e-04 1.219201e+00 
## 
## $weights
## [1] "npairs"
## 
## $call
## variofit(vario = Vario, cov.model = "exp")
## 
## attr(,"class")
## [1] "summary.variomodel"
</code></pre></div></div>

<p>In this case, the spherical model has a slightly lower sum of squares,
suggesting it provides a better fit to the data.</p>

<p>Now we have a variogram model depicting the covariance between pairs of
points as a function of distance between points, we can use it to Krig
values at prediction locations. To allow us to compare with IDW, first
get grid of points from the IDW example for comparison</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Create prediction grid</span><span class="w">
</span><span class="n">IDW</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">idw</span><span class="p">(</span><span class="n">ETH_malaria_data_ppp</span><span class="p">,</span><span class="w"> </span><span class="n">power</span><span class="o">=</span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="o">=</span><span class="s2">"pixels"</span><span class="p">)</span><span class="w">
</span><span class="n">pred_grid_x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">))</span><span class="w">
</span><span class="n">pred_grid_y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sort</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">yrow</span><span class="p">,</span><span class="nf">length</span><span class="p">(</span><span class="n">IDW</span><span class="o">$</span><span class="n">xcol</span><span class="p">)))</span><span class="w">
</span><span class="n">pred_grid</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cbind</span><span class="p">(</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="n">pred_grid_y</span><span class="p">)</span><span class="w">

</span><span class="c1"># 2. Now krig to those points</span><span class="w">
</span><span class="n">KrigPred</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">krige.conv</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="o">=</span><span class="n">pred_grid</span><span class="p">,</span><span class="w">
                       </span><span class="n">krige</span><span class="o">=</span><span class="n">krige.control</span><span class="p">(</span><span class="n">obj.model</span><span class="o">=</span><span class="n">VarioMod_sph</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## krige.conv: model with constant mean
## krige.conv: Kriging performed using global neighbourhood
</code></pre></div></div>

<p>Visualize predictions</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span><span class="p">(</span><span class="n">KrigPred</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">heat.colors</span><span class="p">(</span><span class="m">50</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-41-1.png" alt="" /></p>

<p>If you want to create a raster of your predictions, you can use the
<code class="language-plaintext highlighter-rouge">rasterFromXYZ</code> function</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KrigPred_raster</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rasterFromXYZ</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">pred_grid_x</span><span class="p">,</span><span class="w">
                                 </span><span class="n">y</span><span class="o">=</span><span class="n">pred_grid_y</span><span class="p">,</span><span class="w">
                                 </span><span class="n">z</span><span class="o">=</span><span class="n">KrigPred</span><span class="o">$</span><span class="n">predict</span><span class="p">))</span><span class="w">

</span><span class="n">plot</span><span class="p">(</span><span class="n">KrigPred_raster</span><span class="p">)</span><span class="w">
</span><span class="n">points</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w">
       </span><span class="n">cex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-42-1.png" alt="" /></p>

<p>Generating cross-validated predictions in straightforward in geoR using
the
<a href="https://www.rdocumentation.org/packages/geoR/versions/1.8-1/topics/xvalid"><code class="language-plaintext highlighter-rouge">xvlalid</code></a>
function. Two types of validation are possible: 1. leaving-on-out cross
validation where each data location (all or a subset) is removed in turn
and predicted using the remaining locations, for a given model. 2.
External validation which can predict to locations outside of the
dataset Here we will use the default leave-one-out xvalidation for all
points</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xvalid_result</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot on log odds scale</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">data</span><span class="p">,</span><span class="n">xvalid_result</span><span class="o">$</span><span class="n">predicted</span><span class="p">,</span><span class="w"> </span><span class="n">asp</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w">
     </span><span class="n">xlab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Observed prevalence"</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Cross-validated predicted prevalence"</span><span class="p">)</span><span class="w">
</span><span class="n">abline</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-3/unnamed-chunk-43-1.png" alt="" /></p>

<p>You might notice that some of the kriged values are &lt;0. As we are
modeling probabilities this can’t be true. In these situations, it is
possible to apply a transformation to your data before kriging and then
back-transform results. One transformation useful for probabilities is
the logit transform (used in logistic regression). The <code class="language-plaintext highlighter-rouge">logit</code> and
<code class="language-plaintext highlighter-rouge">inv.logit</code> functions from the package <code class="language-plaintext highlighter-rouge">gtools</code> can be used for this.
Note that it doesn’t work if you have 0 values as you can’t log(0). You
can add a small amount to avoid this situation. The process would look
like this</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add small amount to avoid zeros</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">0.001</span><span class="w">

</span><span class="c1"># Apply logit transform and convert to geodata</span><span class="w">
</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">logit</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr_adj</span><span class="p">)</span><span class="w">
</span><span class="n">ETH_malaria_data_geo_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.geodata</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"pf_pr_logit"</span><span class="p">)])</span><span class="w">

</span><span class="c1"># Fit (spherical) variogram</span><span class="w">
</span><span class="n">Vario_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variog</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">max.dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaxDist</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variog: computing omnidirectional variogram
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VarioMod_sph_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">variofit</span><span class="p">(</span><span class="n">Vario_logit</span><span class="p">,</span><span class="w"> </span><span class="n">cov.model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"sph"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## variofit: covariance model used is spherical 
## variofit: weights used: npairs 
## variofit: minimisation function used: optim

## Warning in variofit(Vario_logit, cov.model = "sph"): initial values not provided
## - running the default search

## variofit: searching for best initial value ... selected values:
##               sigmasq phi    tausq  kappa
## initial.value "1.16"  "2.45" "0.15" "0.5"
## status        "est"   "est"  "est"  "fix"
## loss value: 448.598010419967
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get CV kriged predictions</span><span class="w">
</span><span class="n">xvalid_result_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">xvalid</span><span class="p">(</span><span class="n">ETH_malaria_data_geo_logit</span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VarioMod_sph_logit</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## xvalid: number of data locations       = 203
## xvalid: number of validation locations = 203
## xvalid: performing cross-validation at location ... 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 
## xvalid: end of cross-validation
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xvalid_result_inv_logit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">inv.logit</span><span class="p">(</span><span class="n">xvalid_result_logit</span><span class="o">$</span><span class="n">predicted</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="pop-quiz">Pop quiz</h2>

<ul>
  <li>How could you compare how well the best fitting IDW performs versus
kriging?</li>
  <li>Which appears to be more accurate?</li>
  <li>Can you visualize where predictions from IDW differ to kriging?</li>
  <li>Does inclusion of a trend surface improve kriging estimates?</li>
</ul>

<p>Answers
<a href="https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/code/week_3_cheat_sheet.R">here</a></p>

<h2 id="key-readings">Key readings</h2>

<h4 id="good-overview">Good overview</h4>

<p>Pfeiffer, D., T. P. Robinson, M. Stevenson, K. B. Stevens, D. J. Rogers
and A. C. Clements (2008). Spatial analysis in epidemiology, Oxford
University Press Oxford. Chapter 6.</p>

<h4 id="technical-paper-covering-kernel-estimation-of-relative-risk-key-reference-but-not-necessary-to-understand-in-detail">Technical paper covering kernel estimation of relative risk. Key reference but not necessary to understand in detail.</h4>

<p>Kelsall, Julia E., and Peter J. Diggle. “Kernel estimation of relative
risk.” Bernoulli 1.1-2 (1995): 3-16.</p>

<h4 id="illustration-of-the-kelsall-diggle-approach-used-to-map-sleeping-sickness-risk">Illustration of the Kelsall Diggle approach used to map sleeping sickness risk</h4>

<p><a href="https://journals.plos.org/plosntds/article?id=10.1371/journal.pntd.0001859">Simarro, Pere P., et al. ”Estimating and mapping the population at risk
of sleeping sickness.” PLoS neglected tropical diseases 6.10 (2012):
e1859.</a></p>

<h2 id="additional-readings">Additional readings</h2>

<h4 id="nice-example-of-kriging-applied-across-space-and-time">Nice example of kriging applied across space and time</h4>

<p><a href="https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0030271">Gething, Peter W., et al. ”A local space–time kriging approach applied
to a national outpatient malaria data set.” Computers &amp; geosciences
33.10 (2007):
1337-1350.</a></p>

<h4 id="additional-example-of-kelsall-diggle-in-action">Additional example of Kelsall Diggle in action</h4>

<p>Di Salvo, Francesca, et al. ”Spatial variation in mortality risk for
hematological malignancies near a petrochemical refinery: A
population-based case-control study.” Environmental research 140 (2015):
641-648.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[This week we are going to explore methods to understand and predict risk across space from point data. These may be point level data (i.e. measurements of something of interest at particular points) or point process data (i.e. occurences of events in a given area). When you load this week’s libraries, it may prompt you to download XQuartz]]></summary></entry><entry><title type="html">Week 4 - Analysis of spatial clustering</title><link href="http://localhost:4000/week-4/" rel="alternate" type="text/html" title="Week 4 - Analysis of spatial clustering" /><published>2022-02-25T00:00:00-08:00</published><updated>2022-02-25T00:00:00-08:00</updated><id>http://localhost:4000/week-4</id><content type="html" xml:base="http://localhost:4000/week-4/"><![CDATA[<h3 id="aim">Aim</h3>

<p>To introduce methods for exploring clustering in spatial data</p>

<h3 id="content">Content</h3>

<p>This post provides an introduction to methods for exploring clustering
in different types of spatial data. The approaches will be explored
together in R, followed by an opportunity to adapt the code and run the
analysis yourself.</p>

<h3 id="datasets">Datasets</h3>

<ol>
  <li>Malaria point prevalence data at the village level from Burkina Faso</li>
  <li>Leukemia data at the census tract level from New York State</li>
  <li>Malaria case event data and population controls from northern
Namibia</li>
</ol>

<p>First we will attach the libraries used for visualization.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">rgdal</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ggplot2</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">plotrix</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">maptools</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">RColorBrewer</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">geoR</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">plotrix</span><span class="p">)</span><span class="w"> 
</span><span class="n">library</span><span class="p">(</span><span class="n">car</span><span class="p">)</span><span class="w">  </span><span class="c1"># contains a function for logistic transformation (log odds) to make more normal</span><span class="w">
</span></code></pre></div></div>

<p>These libraries are for spatial data management and point process
analysis.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">

</span><span class="c1"># Moran's I and spatial dependencies</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spdep</span><span class="p">)</span><span class="w"> </span><span class="c1"># Spatial Dependence: Weighting Schemes, Statistics and Models</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">ape</span><span class="p">)</span><span class="w"> </span><span class="c1"># Analyses of Phylogenetics and Evolution</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">pgirmess</span><span class="p">)</span><span class="w"> </span><span class="c1"># Data Analysis in Ecology</span><span class="w">

</span><span class="c1"># Libraries for point processes</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">spatstat</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">splancs</span><span class="p">)</span><span class="w"> </span><span class="c1"># K-function</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">smacpod</span><span class="p">)</span><span class="w"> </span><span class="c1"># Spatial scanning statistic</span><span class="w">
</span></code></pre></div></div>

<p>We’re going to load in some malaria data from Burkina Faso and visualize
it using Leaflet to see if we can initially assess if there may be
evidence of spatial clustering. What do you think?</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Open BF malaria data</span><span class="w">
</span><span class="n">BF_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/BF_malaria_data.csv"</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">BF_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"BFA"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">proj4string</span><span class="p">(</span><span class="n">BF_Adm_1</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">CRS</span><span class="p">(</span><span class="s1">'+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 '</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning in proj4string(obj): CRS object has comment, which is lost in output; in tests, see
## https://cran.r-project.org/web/packages/sp/vignettes/CRS_warnings.html
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculate prevalence</span><span class="w">
</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">prevalence</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">positives</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">examined</span><span class="w">

</span><span class="c1"># What do the data look like - do you see evidence of spatial clustering?</span><span class="w">
</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="s2">"Oranges"</span><span class="p">,</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">prevalence</span><span class="p">)</span><span class="w">
</span><span class="n">leaflet</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="o">~</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">fillOpacity</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w">
                                                             </span><span class="n">fillColor</span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="n">pal</span><span class="p">(</span><span class="n">prevalence</span><span class="p">),</span><span class="w"> </span><span class="n">radius</span><span class="o">=~</span><span class="n">prevalence</span><span class="o">*</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">stroke</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pal</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="n">prevalence</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-4-1.png" alt="" /></p>

<h2 id="part-i-testing-for-spatial-autocorrelation-in-point-level-data">Part I: Testing for spatial autocorrelation in point-level data</h2>

<h3 id="global-spatial-autocorrelation">Global spatial autocorrelation</h3>

<p>In this section we’re going to look at some more formal statistical
tests of global spatial autocorrelation. We’ll look at two general ways
of doing this: using ‘Moran’s I’ and using correlograms. These can each
be done using multiple different packages in R.</p>

<p>Approach 1: Calculate Moran’s I using a distance based matrix</p>

<p>First we will look at the distribution of the prevalence data to see if
they are close to normally distributed. If the are very skewed, we will
need to transform them because the Moran’s I test produces a comparison
to the normal distribution. Here, we will use the logit transformation
to produce a more normal distribution. Then we will calculate the
distance between each of the points and use the inverse of the distance
matrix to produce a matrix of weights that we will use to calculate
Moran’s I.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">prevalence</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Prevalence"</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">""</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-5-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">logit</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">prevalence</span><span class="p">)</span><span class="w">
</span><span class="n">hist</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Log odds"</span><span class="p">,</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">""</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-5-2.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Generate a distance matrix</span><span class="w">
</span><span class="n">BF.dists</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as.matrix</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">)))</span><span class="w">
</span><span class="nf">dim</span><span class="p">(</span><span class="n">BF.dists</span><span class="p">)</span><span class="w"> </span><span class="c1"># 109 x 109 matrix of distance between all sets of points</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 109 109
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Take the inverse of the matrix values so that closer values have a larger weight and vs vs</span><span class="w">
</span><span class="n">BF.dists.inv</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span><span class="o">/</span><span class="n">BF.dists</span><span class="w">
</span><span class="n">diag</span><span class="p">(</span><span class="n">BF.dists.inv</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="c1"># replace the diagonal values with zero</span><span class="w">

</span><span class="c1"># Computes Moran's I autocorrelation coefficient of x giving a matrix of weights (here based on distance) </span><span class="w">
</span><span class="n">Moran.I</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">,</span><span class="w"> </span><span class="n">BF.dists.inv</span><span class="p">)</span><span class="w">                 </span><span class="c1"># from the "ape" package</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## $observed
## [1] 0.0666352
## 
## $expected
## [1] -0.009259259
## 
## $sd
## [1] 0.01639855
## 
## $p.value
## [1] 3.690017e-06
</code></pre></div></div>

<p>Approach 2: Create a correlogram to explore Moran’s I over different
spatial lags. The “pgirmess” package requires spdep (which also has
correlogram options) but is much simplier and user-friendly.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculate the maximum distance between points</span><span class="w">
</span><span class="n">maxDist</span><span class="o">&lt;-</span><span class="nf">max</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">)))</span><span class="w">
</span><span class="n">maxDist</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 7.534414
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xy</span><span class="o">=</span><span class="n">cbind</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">)</span><span class="w">
</span><span class="n">pgi.cor</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">correlog</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">=</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">,</span><span class="w"> </span><span class="n">method</span><span class="o">=</span><span class="s2">"Moran"</span><span class="p">,</span><span class="w"> </span><span class="n">nbclass</span><span class="o">=</span><span class="m">10</span><span class="p">)</span><span class="w">   </span><span class="c1"># "pgirmess" package</span><span class="w">
</span><span class="c1"># coords = xy cordinates, z= vector of values at each location and nbclass = the number of bins</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">pgi.cor</span><span class="p">)</span><span class="w"> </span><span class="c1"># statistically significant values (p&lt;0.05) are plotted in red</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-6-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pgi.cor</span><span class="w"> </span><span class="c1"># distclass is midpoint for the bin</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Moran I statistic 
##       dist.class        coef      p.value    n
##  [1,]  0.4121237  0.13669304 6.435709e-04 1092
##  [2,]  1.1618390  0.13700359 3.059924e-06 2176
##  [3,]  1.9115538  0.09009855 2.482029e-05 2680
##  [4,]  2.6612685 -0.02082828 6.589705e-01 2172
##  [5,]  3.4109833 -0.10323722 9.946353e-01 1376
##  [6,]  4.1606981 -0.16259353 9.997622e-01 1146
##  [7,]  4.9104129 -0.20629178 9.991684e-01  662
##  [8,]  5.6601277 -0.27492632 9.990240e-01  320
##  [9,]  6.4098425 -0.11874035 7.536360e-01  128
## [10,]  7.1595572 -0.25618534 7.320096e-01   20
</code></pre></div></div>

<p>Based on the correlogram, over what spatial lags are there evidence for
spatial autocorrelation? Is this clustering positive or negative?</p>

<p>Compare the correlogram to the results from a semivariogram approach:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BF_malaria_data_geo</span><span class="o">&lt;-</span><span class="n">as.geodata</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="s2">"latitude"</span><span class="p">,</span><span class="s2">"log_odds"</span><span class="p">)])</span><span class="w">

</span><span class="c1"># Generate and plot a binned variogram (10 bins) NB: have made for full max distance (even though likely inaccurate) for comparison</span><span class="w">
</span><span class="n">Vario</span><span class="o">&lt;-</span><span class="n">variog</span><span class="p">(</span><span class="n">BF_malaria_data_geo</span><span class="p">,</span><span class="n">max.dist</span><span class="o">=</span><span class="m">7.53</span><span class="p">,</span><span class="n">uvec</span><span class="o">=</span><span class="n">seq</span><span class="p">(</span><span class="m">0.4121237</span><span class="p">,</span><span class="m">7.1595572</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="m">10</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Vario</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">pgi.cor</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-8-1.png" alt="" /></p>

<p>Approach 3: Calculate Moran’s I using a binary distance matrix. For this
approach, we are going to create sets of ‘neighbors’ based upon their
proximity. This approach can be used with point data but is especially
useful for areal data, as we will see shortly.</p>

<p>For this approach, you will need to consider what is a sensible distance
to classify points as neighbors. Considerations might include the scale
of analysis and the distribution of points. In the comparison of
different neighboring structures, you can see that increasing the
distance within which one is considered a neighbor dramatically
increases the overall number of neighbor linkages.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coords</span><span class="o">&lt;-</span><span class="n">coordinates</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="w"> </span><span class="c1"># set spatial coordinates to create a spatial object</span><span class="w">
</span><span class="n">IDs</span><span class="o">&lt;-</span><span class="n">row.names</span><span class="p">(</span><span class="n">as.data.frame</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span><span class="w">

</span><span class="c1"># In this approach, we chose a distance d such that pairs of points with distances less than </span><span class="w">
</span><span class="c1"># d are neighbors and those further apart are not. </span><span class="w">

</span><span class="n">Neigh_nb</span><span class="o">&lt;-</span><span class="n">knn2nb</span><span class="p">(</span><span class="n">knearneigh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">longlat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="n">row.names</span><span class="o">=</span><span class="n">IDs</span><span class="p">)</span><span class="w">     </span><span class="c1"># using the "spdep" package</span><span class="w">
</span><span class="c1"># assigns at least one neighbor to each and calculates the distances between</span><span class="w">
</span><span class="n">dsts</span><span class="o">&lt;-</span><span class="n">unlist</span><span class="p">(</span><span class="n">nbdists</span><span class="p">(</span><span class="n">Neigh_nb</span><span class="p">,</span><span class="n">coords</span><span class="p">))</span><span class="w"> </span><span class="c1"># returns the distance between nearest neighbors for each point</span><span class="w">
</span><span class="n">summary</span><span class="p">(</span><span class="n">dsts</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
## 0.03727 0.12693 0.19004 0.22742 0.27488 1.10524
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">max_1nn</span><span class="o">&lt;-</span><span class="nf">max</span><span class="p">(</span><span class="n">dsts</span><span class="p">)</span><span class="w">
</span><span class="n">max_1nn</span><span class="w"> </span><span class="c1"># maximum distance to provide at least one neighbor to each point</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 1.10524
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We create different neighbor structures based upon distance</span><span class="w">
</span><span class="n">Neigh_kd1</span><span class="o">&lt;-</span><span class="n">dnearneigh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">d1</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="o">=</span><span class="n">max_1nn</span><span class="p">,</span><span class="w"> </span><span class="n">row.names</span><span class="o">=</span><span class="n">IDs</span><span class="p">)</span><span class="w">   </span><span class="c1"># neighbors within maximum distance</span><span class="w">
</span><span class="n">Neigh_kd2</span><span class="o">&lt;-</span><span class="n">dnearneigh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">d1</span><span class="o">=</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="o">=</span><span class="m">2</span><span class="o">*</span><span class="n">max_1nn</span><span class="p">,</span><span class="w"> </span><span class="n">row.names</span><span class="o">=</span><span class="n">IDs</span><span class="p">)</span><span class="w"> </span><span class="c1"># neighbors within 2X maximum distance</span><span class="w">

</span><span class="n">nb_1</span><span class="o">&lt;-</span><span class="nf">list</span><span class="p">(</span><span class="n">d1</span><span class="o">=</span><span class="n">Neigh_kd1</span><span class="p">,</span><span class="w"> </span><span class="n">d2</span><span class="o">=</span><span class="n">Neigh_kd2</span><span class="p">)</span><span class="w"> </span><span class="c1"># list of neighbor structures</span><span class="w">
</span><span class="n">sapply</span><span class="p">(</span><span class="n">nb_1</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">is.symmetric.nb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">verbose</span><span class="o">=</span><span class="nb">F</span><span class="p">,</span><span class="w"> </span><span class="n">force</span><span class="o">=</span><span class="nb">T</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   d1   d2 
## TRUE TRUE
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Checks for symmetry (i.e. if i is a neighbor of j, then j is a neighbor of i). Does not always hold for k-nearest neighbours</span><span class="w">
</span><span class="n">sapply</span><span class="p">(</span><span class="n">nb_1</span><span class="p">,</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="n">n.comp.nb</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">$</span><span class="n">nc</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## d1 d2 
##  1  1
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Number of disjoint connected subgraphs</span><span class="w">

</span><span class="c1"># Plot neighbors comparing the two distances </span><span class="w">
</span><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">mar</span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Neigh_kd1</span><span class="p">,</span><span class="w"> </span><span class="n">coords</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"green"</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Neigh_kd2</span><span class="p">,</span><span class="w"> </span><span class="n">coords</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"green"</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-9-1.png" alt="" /></p>

<p>To run a spatial test for clustering, we need to assign weights to the
neighbor list. We will use the neighbor structure with all neighbors
within the maximum neighbor distance between any two points.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#assign weights; </span><span class="w">
</span><span class="n">weights</span><span class="o">&lt;-</span><span class="n">nb2listw</span><span class="p">(</span><span class="n">Neigh_kd1</span><span class="p">,</span><span class="w"> </span><span class="n">style</span><span class="o">=</span><span class="s2">"W"</span><span class="p">)</span><span class="w">   </span><span class="c1"># row standardized binary weights, using minimum distance for one neighbor</span><span class="w">
</span><span class="n">weights</span><span class="w">                                   </span><span class="c1"># "B" is simplest binary weights</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 109 
## Number of nonzero links: 1914 
## Percentage nonzero weights: 16.10976 
## Average number of links: 17.55963 
## 
## Weights style: W 
## Weights constants summary:
##     n    nn  S0       S1       S2
## W 109 11881 109 16.44475 442.0046
</code></pre></div></div>

<p>Using this weights matrix, we can now run the Moran’s I test on the
logit transformed prevalence using the neighborhood matrix. How do the
results compare to other approaches?</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">moran.test</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">listw</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span><span class="w">  </span><span class="c1">#using row standardised weights</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##  Moran I test under randomisation
## 
## data:  BF_malaria_data$log_odds  
## weights: weights    
## 
## Moran I statistic standard deviate = 4.7332, p-value = 1.105e-06
## alternative hypothesis: greater
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.154300895      -0.009259259       0.001194126
</code></pre></div></div>

<p>We can also use a simulation approach: we simulate the test statistic
using random permutations of BF_malaria_data$log_odds so that the
values are randomly assigned to locations and the statistic is computed
nsim times; we compare the observed statistic to the distribution. What
do you conclude about evidence for spatial autocorrelation?</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set.seed</span><span class="p">(</span><span class="m">1234</span><span class="p">)</span><span class="w">
</span><span class="n">bperm</span><span class="o">&lt;-</span><span class="n">moran.mc</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">listw</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span><span class="n">nsim</span><span class="o">=</span><span class="m">999</span><span class="p">)</span><span class="w">
</span><span class="n">bperm</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##  Monte-Carlo simulation of Moran I
## 
## data:  BF_malaria_data$log_odds 
## weights: weights  
## number of simulations + 1: 1000 
## 
## statistic = 0.1543, observed rank = 1000, p-value = 0.001
## alternative hypothesis: greater
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#statistic = 0.15, observed rank = 1000, p-value = 0.001</span><span class="w">

</span><span class="c1"># Plot simulated test statistics</span><span class="w">
</span><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">mar</span><span class="o">=</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">
</span><span class="n">hist</span><span class="p">(</span><span class="n">bperm</span><span class="o">$</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="n">freq</span><span class="o">=</span><span class="nb">T</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="o">=</span><span class="m">20</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Simulated Moran's I"</span><span class="p">)</span><span class="w">
</span><span class="n">abline</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="m">0.15</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-12-1.png" alt="" /></p>

<p>We can now also take a look at running Moran’s I for areal data
(polygons), using a dataset on leukemia from New York (Turnbull et al
1990). We will also use these data later in the course in week 7.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nydata</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rgdal</span><span class="o">::</span><span class="n">readOGR</span><span class="p">(</span><span class="s2">"https://github.com/phw272c/phw272c.github.io/raw/master/data/nydata.geojson"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## OGR data source with driver: GeoJSON 
## Source: "https://github.com/phw272c/phw272c.github.io/raw/master/data/nydata.geojson", layer: "nydata"
## with 281 features
## It has 17 fields
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#lets take a look at the data</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">nydata</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##          AREANAME     AREAKEY        X        Y POP8 TRACTCAS  PROPCAS
## 0 Binghamton city 36007000100 4.069397 -67.3533 3540     3.08 0.000870
## 1 Binghamton city 36007000200 4.639371 -66.8619 3560     4.08 0.001146
## 2 Binghamton city 36007000300 5.709063 -66.9775 3739     1.09 0.000292
## 3 Binghamton city 36007000400 7.613831 -65.9958 2784     1.07 0.000384
## 4 Binghamton city 36007000500 7.315968 -67.3183 2571     3.06 0.001190
## 5 Binghamton city 36007000600 8.558753 -66.9344 2729     1.06 0.000388
##   PCTOWNHOME PCTAGE65P        Z  AVGIDIST PEXPOSURE   Cases       Xm       Ym
## 0  0.3277311 0.1466102  0.14197 0.2373852  3.167099 3.08284 4069.397 -67353.3
## 1  0.4268293 0.2351124  0.35555 0.2087413  3.038511 4.08331 4639.371 -66861.9
## 2  0.3377396 0.1380048 -0.58165 0.1708548  2.838229 1.08750 5709.063 -66977.5
## 3  0.4616048 0.1188937 -0.29634 0.1406045  2.643366 1.06515 7613.831 -65995.8
## 4  0.1924370 0.1415791  0.45689 0.1577753  2.758587 3.06017 7315.968 -67318.3
## 5  0.3651786 0.1410773 -0.28123 0.1726033  2.848411 1.06386 8558.753 -66934.4
##     Xshift  Yshift
## 0 423391.0 4661502
## 1 423961.0 4661993
## 2 425030.6 4661878
## 3 426935.4 4662859
## 4 426637.5 4661537
## 5 427880.3 4661921
</code></pre></div></div>

<p>For now, with this dataset we are only interested in seeing if there is
global clustering in the area-level case incidence. In the dataset we
find a ‘Cases’ variable that gives the estimated number of cases per
area. We need to also consider the population in each area however,
because areas with higher populations are more likely to have more cases
just due to population size. So we will first create an incidence
variable to normalize the case data by population size.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nydata</span><span class="o">$</span><span class="n">inc_per_1000</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="n">nydata</span><span class="o">$</span><span class="n">Cases</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nydata</span><span class="o">$</span><span class="n">POP8</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">1000</span><span class="w">
</span></code></pre></div></div>

<p>As these are areas and not points, we will not use distance to define
the neighbors, but rather which polygons are directly touching one
another along a boundary or boundary point.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sf</span><span class="o">::</span><span class="n">sf_use_s2</span><span class="p">(</span><span class="kc">FALSE</span><span class="p">)</span><span class="w"> </span><span class="c1"># https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Spherical geometry (s2) switched off
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Contiguity neighbors - all that share a boundary point</span><span class="w">
</span><span class="n">nydata_nb</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">poly2nb</span><span class="p">(</span><span class="n">nydata</span><span class="p">)</span><span class="w">  </span><span class="c1">#queen contiguity</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning in st_is_longlat(pl): bounding box has potentially an invalid value
## range for longlat data

## Warning in st_is_longlat(pl): bounding box has potentially an invalid value
## range for longlat data

## Warning in st_is_longlat(x): bounding box has potentially an invalid value range
## for longlat data

## although coordinates are longitude/latitude, st_intersects assumes that they are planar
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nydata_nbr</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">poly2nb</span><span class="p">(</span><span class="n">nydata</span><span class="p">,</span><span class="w"> </span><span class="n">queen</span><span class="o">=</span><span class="nb">F</span><span class="p">)</span><span class="w">  </span><span class="c1">#rook contiguity</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Warning in st_is_longlat(pl): bounding box has potentially an invalid value
## range for longlat data

## Warning in st_is_longlat(pl): bounding box has potentially an invalid value
## range for longlat data

## Warning in st_is_longlat(x): bounding box has potentially an invalid value range
## for longlat data

## although coordinates are longitude/latitude, st_intersects assumes that they are planar
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#coordinates</span><span class="w">
</span><span class="n">coords_ny</span><span class="o">&lt;-</span><span class="n">coordinates</span><span class="p">(</span><span class="n">nydata</span><span class="p">)</span><span class="w">

</span><span class="c1">#view and compare the neighbors</span><span class="w">
</span><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">nydata</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">nydata_nb</span><span class="p">,</span><span class="n">coords_ny</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"blue"</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">nydata</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">nydata_nbr</span><span class="p">,</span><span class="n">coords_ny</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="s2">"green"</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-15-1.png" alt="" /></p>

<p>As above, we then set the weights for the neighbor matrix. The default
is row standardized (each row sums to one), or binary, where neighbors
are 1 and 0 otherwise.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##set weights - contiguity</span><span class="w">
</span><span class="c1">#weights style W - row standardized</span><span class="w">
</span><span class="n">nydata_w</span><span class="o">&lt;-</span><span class="n">nb2listw</span><span class="p">(</span><span class="n">nydata_nb</span><span class="p">)</span><span class="w">
</span><span class="n">nydata_w</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 281 
## Number of nonzero links: 1624 
## Percentage nonzero weights: 2.056712 
## Average number of links: 5.779359 
## 
## Weights style: W 
## Weights constants summary:
##     n    nn  S0       S1       S2
## W 281 78961 281 106.6125 1164.157
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#weights style B - binary</span><span class="w">
</span><span class="n">nydata_wB</span><span class="o">&lt;-</span><span class="n">nb2listw</span><span class="p">(</span><span class="n">nydata_nb</span><span class="p">,</span><span class="n">style</span><span class="o">=</span><span class="s2">"B"</span><span class="p">)</span><span class="w">
</span><span class="n">nydata_wB</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 281 
## Number of nonzero links: 1624 
## Percentage nonzero weights: 2.056712 
## Average number of links: 5.779359 
## 
## Weights style: B 
## Weights constants summary:
##     n    nn   S0   S1    S2
## B 281 78961 1624 3248 41440
</code></pre></div></div>

<p>Based on this weights matrix, we can now do an initial check of spatial
autocorrelation in the data. What do you conclude? We will return to
this dataset in week 7.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##moran's tests of global spatial autocorrelation</span><span class="w">
</span><span class="n">moran.test</span><span class="p">(</span><span class="n">nydata</span><span class="o">$</span><span class="n">inc_per_1000</span><span class="p">,</span><span class="n">listw</span><span class="o">=</span><span class="n">nydata_w</span><span class="p">)</span><span class="w">  </span><span class="c1">#using row standardized</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
##  Moran I test under randomisation
## 
## data:  nydata$inc_per_1000  
## weights: nydata_w    
## 
## Moran I statistic standard deviate = 1.8649, p-value = 0.0311
## alternative hypothesis: greater
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.060405798      -0.003571429       0.001176865
</code></pre></div></div>

<h3 id="local-spatial-autocorrelation">Local spatial autocorrelation</h3>

<p>The above approaches examined evidence for global spatial autorrelation.
Now we’re going to look at local measures of clustering. One way to do
this is using ‘Local Moran’s I’, which we will illustrate using the
point-level data from Burkina Faso.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># First calculate the local Moran's I around each point based on the spatial weights object (binary based on at least one neighbor)</span><span class="w">
</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;-</span><span class="n">localmoran</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">,</span><span class="w"> </span><span class="n">weights</span><span class="p">)</span><span class="w">                         </span><span class="c1"># "spdep" package</span><span class="w">

</span><span class="c1"># Print 'LISA' for each point</span><span class="w">
</span><span class="n">Coef</span><span class="o">&lt;-</span><span class="n">printCoefmat</span><span class="p">(</span><span class="n">data.frame</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="n">IDs</span><span class="p">,],</span><span class="w"> </span><span class="n">row.names</span><span class="o">=</span><span class="n">row.names</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span><span class="w">
                              </span><span class="n">check.names</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##                 Ii        E.Ii      Var.Ii    Z.Ii Pr(z != E(Ii))    
##   [1,]  1.8125e-01 -7.7320e-03  2.0321e-01  0.4192      0.6750550    
##   [2,] -1.2819e-01 -7.9011e-04  1.6567e-02 -0.9898      0.3222658    
##   [3,]  1.7760e-01 -1.0791e-02  2.2400e-01  0.3980      0.6905976    
##   [4,]  1.6095e-01 -1.4860e-02  3.0721e-01  0.3172      0.7510925    
##   [5,]  1.4150e-01 -3.5181e-04  5.1692e-03  1.9730      0.0484971 *  
##   [6,] -9.3562e-01 -1.4721e-02  3.8417e-01 -1.4858      0.1373384    
##   [7,]  2.0481e-01 -3.1400e-03  3.1249e-02  1.1763      0.2394560    
##   [8,]  1.0326e-01 -3.9330e-04  3.9249e-03  1.6546      0.0980141 .  
##   [9,]  6.4866e-01 -4.1543e-02  3.9751e-01  1.0947      0.2736389    
##  [10,]  2.2870e-01 -3.6550e-03  4.0807e-02  1.1502      0.2500442    
##  [11,] -6.3207e-02 -8.4035e-04  1.7620e-02 -0.4698      0.6384687    
##  [12,]  5.2887e-02 -1.3459e-04  1.0018e-03  1.6752      0.0938957 .  
##  [13,] -3.1234e-02 -5.2641e-05  4.7285e-04 -1.4339      0.1515894    
##  [14,] -2.7457e-01 -3.2778e-03  2.9348e-02 -1.5836      0.1132854    
##  [15,]  1.8953e+00 -3.2990e-02  2.5998e-01  3.7819      0.0001556 ***
##  [16,]  3.7821e-01 -5.6326e-03  3.2807e-02  2.1192      0.0340724 *  
##  [17,] -7.7082e-02 -5.2710e-05  3.9237e-04 -3.8888      0.0001008 ***
##  [18,]  1.6616e-01 -2.7475e-03  1.6049e-02  1.3333      0.1824444    
##  [19,]  1.4622e-01 -2.3970e-03  1.6356e-02  1.1621      0.2452126    
##  [20,]  2.1928e-01 -4.6906e-03  2.5458e-02  1.4037      0.1603973    
##  [21,]  2.6115e+00 -4.3279e-02  4.6398e-01  3.8975       9.72e-05 ***
##  [22,]  6.0848e-01 -3.6628e-03  2.7167e-02  3.7139      0.0002041 ***
##  [23,]  1.4323e-01 -2.4940e-03  1.5713e-02  1.1625      0.2450275    
##  [24,]  2.7566e-03 -3.0994e-05  2.7841e-04  0.1671      0.8673174    
##  [25,] -2.7090e-01 -1.6415e-03  8.3470e-03 -2.9472      0.0032066 ** 
##  [26,]  2.1542e+00 -3.8421e-02  3.6883e-01  3.6104      0.0003057 ***
##  [27,]  1.6954e+00 -5.6051e-02  3.0991e-01  3.1460      0.0016550 ** 
##  [28,] -4.3038e-01 -2.1343e-03  1.3451e-02 -3.6925      0.0002221 ***
##  [29,] -4.5056e-01 -4.9503e-03  2.8853e-02 -2.6234      0.0087059 ** 
##  [30,]  2.4252e+00 -1.2102e-01  8.6691e-01  2.7346      0.0062448 ** 
##  [31,]  9.2584e-02 -8.5393e-05  6.9586e-04  3.5130      0.0004431 ***
##  [32,] -3.1174e-02 -9.1729e-03  5.7403e-02 -0.0918      0.9268343    
##  [33,]  6.4106e-01 -4.5588e-03  3.6983e-02  3.3572      0.0007874 ***
##  [34,] -1.3437e-01 -4.3284e-04  3.2208e-03 -2.3600      0.0182749 *  
##  [35,] -1.8818e-03 -5.0218e-06  3.1717e-05 -0.3332      0.7389483    
##  [36,] -5.0239e-01 -7.1528e-03  5.2867e-02 -2.1539      0.0312505 *  
##  [37,]  1.4153e-02 -4.8535e-05  2.1754e-04  0.9629      0.3356070    
##  [38,]  4.0998e-01 -3.6404e-03  3.2582e-02  2.2915      0.0219368 *  
##  [39,]  1.6427e-02 -5.2015e-03  7.6056e-02  0.0784      0.9374896    
##  [40,] -2.7545e-01 -1.2675e-03  1.1371e-02 -2.5712      0.0101353 *  
##  [41,] -1.2604e-01 -3.7519e-02  1.2875e-01 -0.2467      0.8051351    
##  [42,]  3.6265e-01 -5.1487e-02  1.8386e-01  0.9658      0.3341195    
##  [43,]  1.7248e-03 -1.1431e-06  3.8659e-06  0.8778      0.3800330    
##  [44,] -3.3785e-01 -1.1374e-02  3.8030e-02 -1.6741      0.0941034 .  
##  [45,]  3.0104e-01 -1.2465e-02  4.1632e-02  1.5365      0.1244130    
##  [46,]  6.7195e-02 -1.4421e-03  4.8702e-03  0.9835      0.3253470    
##  [47,]  1.4938e-01 -2.7255e-02  9.4529e-02  0.5745      0.5656223    
##  [48,]  4.3522e-01 -1.4718e-02  5.4593e-02  1.9257      0.0541442 .  
##  [49,] -1.6736e-01 -4.1614e-03  1.2665e-02 -1.4502      0.1470058    
##  [50,]  4.1369e-01 -3.7769e-02  1.1676e-01  1.3212      0.1864341    
##  [51,] -5.0223e-01 -3.4350e-02  9.2048e-02 -1.5421      0.1230389    
##  [52,]  3.6965e-01 -2.8057e-03  2.0828e-02  2.5808      0.0098569 ** 
##  [53,] -3.0961e-01 -1.0434e-02  2.8654e-02 -1.7674      0.0771670 .  
##  [54,] -1.4140e-02 -6.2934e-05  2.1283e-04 -0.9649      0.3345770    
##  [55,]  2.0417e-01 -5.6924e-03  1.5707e-02  1.6745      0.0940283 .  
##  [56,]  3.0584e-03 -6.8129e-05  3.2507e-04  0.1734      0.8623295    
##  [57,]  4.8415e-01 -4.2565e-02  1.3093e-01  1.4556      0.1454901    
##  [58,] -1.3320e-02 -6.0679e-04  2.0509e-03 -0.2807      0.7789243    
##  [59,] -1.3369e-02 -3.2063e-05  7.7571e-05 -1.5143      0.1299608    
##  [60,]  5.3118e-02 -5.1915e-04  1.2013e-03  1.5475      0.1217365    
##  [61,]  1.0467e-01 -1.0876e-03  2.5153e-03  2.1086      0.0349789 *  
##  [62,] -4.9491e-02 -6.3766e-03  2.2590e-02 -0.2869      0.7742217    
##  [63,]  7.2047e-02 -4.2040e-03  1.9976e-02  0.5395      0.5895414    
##  [64,] -2.1793e-01 -4.1259e-03  1.4650e-02 -1.7665      0.0773166 .  
##  [65,] -2.9614e-01 -1.2994e-03  9.6605e-03 -2.9998      0.0027018 ** 
##  [66,]  9.5520e-02 -1.4102e-02  4.9570e-02  0.4924      0.6224591    
##  [67,]  4.5932e-02 -1.8184e-02  5.7360e-02  0.2677      0.7889236    
##  [68,]  9.3542e-01 -4.6004e-02  2.2354e-01  2.0758      0.0379153 *  
##  [69,]  1.3055e-01 -5.0112e-03  5.5872e-02  0.5735      0.5663029    
##  [70,]  1.2863e-01 -2.1095e-03  6.1268e-03  1.6702      0.0948753 .  
##  [71,]  2.1775e-01 -1.4675e-03  1.1942e-02  2.0060      0.0448548 *  
##  [72,] -5.2296e-02 -1.0877e-03  5.9246e-03 -0.6653      0.5058642    
##  [73,] -4.2840e-02 -7.6232e-04  4.1538e-03 -0.6529      0.5138407    
##  [74,] -7.4349e-02 -2.2058e-04  1.5084e-03 -1.9087      0.0563044 .  
##  [75,]  2.4038e-03 -1.7851e-07  6.3646e-07  3.0134      0.0025836 ** 
##  [76,]  3.0589e-02 -1.8076e-04  4.1842e-04  1.5042      0.1325193    
##  [77,]  3.3824e-01 -6.9083e-03  3.2737e-02  1.9076      0.0564413 .  
##  [78,]  5.1673e-01 -8.2918e-03  8.2092e-02  1.8324      0.0668895 .  
##  [79,] -2.1323e-02 -9.0292e-04  2.3893e-03 -0.4178      0.6761299    
##  [80,] -3.5618e-02 -1.5616e-04  4.3329e-04 -1.7036      0.0884505 .  
##  [81,]  7.7589e-02 -9.7284e-03  3.2582e-02  0.4837      0.6285717    
##  [82,] -7.0921e-02 -2.3914e-03  8.5061e-03 -0.7430      0.4574578    
##  [83,]  1.3071e-01 -1.9582e-03  5.9725e-03  1.7166      0.0860512 .  
##  [84,] -1.2850e-02 -7.8278e-06  2.9469e-05 -2.3657      0.0179962 *  
##  [85,]  2.9051e-02 -5.4606e-03  2.0445e-02  0.2414      0.8092748    
##  [86,]  2.2357e-01 -2.4572e-03  7.8750e-03  2.5470      0.0108643 *  
##  [87,]  3.9491e-01 -8.9711e-03  4.2424e-02  1.9609      0.0498962 *  
##  [88,]  7.6021e-02 -1.7009e-03  6.7619e-03  0.9452      0.3445681    
##  [89,]  2.7646e-01 -1.9951e-03  1.9878e-02  1.9750      0.0482679 *  
##  [90,] -7.2328e-02 -3.4831e-04  1.1776e-03 -2.0975      0.0359467 *  
##  [91,]  1.7124e-01 -1.9620e-03  6.6226e-03  2.1284      0.0333060 *  
##  [92,]  2.2277e-01 -2.9446e-03  1.3159e-02  1.9676      0.0491136 *  
##  [93,] -1.6416e-01 -4.6451e-03  2.0724e-02 -1.1081      0.2678358    
##  [94,] -8.5334e-02 -2.9359e-04  1.1688e-03 -2.4875      0.0128645 *  
##  [95,]  1.4523e-01 -3.1646e-02  1.0926e-01  0.5351      0.5925808    
##  [96,]  3.4949e-02 -9.9883e-04  6.3022e-03  0.4528      0.6506747    
##  [97,] -3.7727e-02 -7.8684e-04  4.6053e-03 -0.5443      0.5862018    
##  [98,] -8.3274e-02 -3.7601e-03  1.2669e-02 -0.7064      0.4799202    
##  [99,] -4.5113e-02 -1.8822e-04  8.9800e-04 -1.4992      0.1338279    
## [100,] -5.3629e-01 -1.0667e-02  5.0357e-02 -2.3423      0.0191634 *  
## [101,]  4.6925e-01 -3.1158e-02  2.0648e-01  1.1013      0.2707805    
## [102,]  1.3653e-02 -1.0162e-05  5.9525e-05  1.7710      0.0765650 .  
## [103,]  1.8685e-01 -2.6668e-03  1.6798e-02  1.4622      0.1436856    
## [104,] -8.6863e-03 -3.2087e-05  2.8823e-04 -0.5098      0.6102264    
## [105,]  2.9290e-02 -1.9567e-04  6.9752e-03  0.3531      0.7240497    
## [106,] -2.0335e-02 -1.2801e-03  1.0419e-02 -0.1867      0.8519111    
## [107,]  2.5801e-01 -5.5871e-03  3.5090e-02  1.4072      0.1593723    
## [108,]  4.9384e-02 -2.7835e-04  4.0901e-03  0.7765      0.4374357    
## [109,]  6.4535e-02 -1.2828e-03  1.3965e-01  0.1761      0.8601927    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot the spatial data against its spatially lagged values (the weighted mean of its neighbors)                         </span><span class="w">
</span><span class="n">nci</span><span class="o">&lt;-</span><span class="n">moran.plot</span><span class="p">(</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">,</span><span class="w"> </span><span class="n">listw</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span><span class="w"> 
                </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Log prevalence"</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"Spatially lagged log prev"</span><span class="p">,</span><span class="w"> </span><span class="n">labels</span><span class="o">=</span><span class="nb">T</span><span class="p">,</span><span class="w"> </span><span class="n">pch</span><span class="o">=</span><span class="m">16</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s2">"grey"</span><span class="p">)</span><span class="w">
</span><span class="n">text</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">-5</span><span class="p">,</span><span class="m">-5</span><span class="p">),</span><span class="nf">c</span><span class="p">(</span><span class="m">0.9</span><span class="p">,</span><span class="w"> </span><span class="m">-1.9</span><span class="p">,</span><span class="m">0.9</span><span class="p">,</span><span class="m">-1.9</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s2">"High-High"</span><span class="p">,</span><span class="w"> </span><span class="s2">"High-Low"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Low-High"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Low-Low"</span><span class="p">),</span><span class="w"> </span><span class="n">cex</span><span class="o">=</span><span class="m">0.8</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-20-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Map points that are local outliers in the plot</span><span class="w">
</span><span class="n">infl</span><span class="o">&lt;-</span><span class="n">nci</span><span class="o">$</span><span class="n">is_inf</span><span class="o">==</span><span class="nb">T</span><span class="w"> </span><span class="c1"># find which points are statistically significant outliers</span><span class="w">
</span><span class="nf">sum</span><span class="p">(</span><span class="n">infl</span><span class="o">==</span><span class="nb">T</span><span class="p">)</span><span class="w">    </span><span class="c1">#13 true (12% - more than would expect by chance)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 13
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="o">&lt;-</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="w">
</span><span class="n">lhx</span><span class="o">&lt;-</span><span class="n">cut</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="w"> </span><span class="n">labels</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"L"</span><span class="p">,</span><span class="w"> </span><span class="s2">"H"</span><span class="p">),</span><span class="w"> </span><span class="n">include.lowest</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">

</span><span class="n">wx</span><span class="o">&lt;-</span><span class="n">lag</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="n">BF_malaria_data</span><span class="o">$</span><span class="n">log_odds</span><span class="p">)</span><span class="w">
</span><span class="n">lhwx</span><span class="o">&lt;-</span><span class="n">cut</span><span class="p">(</span><span class="n">wx</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">wx</span><span class="p">),</span><span class="w"> </span><span class="n">mean</span><span class="p">(</span><span class="n">wx</span><span class="p">),</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">wx</span><span class="p">)),</span><span class="w"> </span><span class="n">labels</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"L"</span><span class="p">,</span><span class="w"> </span><span class="s2">"H"</span><span class="p">),</span><span class="w"> </span><span class="n">include.lowest</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span><span class="n">lhlh</span><span class="o">&lt;-</span><span class="n">interaction</span><span class="p">(</span><span class="n">lhx</span><span class="p">,</span><span class="n">lhwx</span><span class="p">,</span><span class="n">infl</span><span class="p">,</span><span class="n">drop</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">

</span><span class="n">names</span><span class="o">&lt;-</span><span class="nf">rep</span><span class="p">(</span><span class="s2">"none"</span><span class="p">,</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">lhlh</span><span class="p">))</span><span class="w">
</span><span class="n">names</span><span class="p">[</span><span class="n">lhlh</span><span class="o">==</span><span class="s2">"L.L.TRUE"</span><span class="p">]</span><span class="o">&lt;-</span><span class="s2">"LL"</span><span class="w">
</span><span class="n">names</span><span class="p">[</span><span class="n">lhlh</span><span class="o">==</span><span class="s2">"H.L.TRUE"</span><span class="p">]</span><span class="o">&lt;-</span><span class="s2">"HL"</span><span class="w">
</span><span class="n">names</span><span class="p">[</span><span class="n">lhlh</span><span class="o">==</span><span class="s2">"L.H.TRUE"</span><span class="p">]</span><span class="o">&lt;-</span><span class="s2">"LH"</span><span class="w">
</span><span class="n">names</span><span class="p">[</span><span class="n">lhlh</span><span class="o">==</span><span class="s2">"H.H.TRUE"</span><span class="p">]</span><span class="o">&lt;-</span><span class="s2">"HH"</span><span class="w">
</span></code></pre></div></div>

<p>We can map the points to show the local clusters.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BF_malaria_localM</span><span class="o">&lt;-</span><span class="n">as.data.frame</span><span class="p">(</span><span class="n">cbind</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">names</span><span class="p">))</span><span class="w">
</span><span class="n">colnames</span><span class="p">(</span><span class="n">BF_malaria_localM</span><span class="p">)</span><span class="o">&lt;-</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"names"</span><span class="p">)</span><span class="w">
</span><span class="n">BF_malaria_localM</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">)]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">lapply</span><span class="p">(</span><span class="w"> </span><span class="n">BF_malaria_localM</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="nf">as.numeric</span><span class="p">(</span><span class="nf">as.character</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">factpal</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorFactor</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="w"> </span><span class="s2">"cyan4"</span><span class="p">,</span><span class="s2">"coral4"</span><span class="p">,</span><span class="s2">"coral"</span><span class="p">,</span><span class="s2">"cyan"</span><span class="p">,</span><span class="s2">"lightgrey"</span><span class="p">),</span><span class="w"> </span><span class="n">names</span><span class="p">)</span><span class="w">
</span><span class="n">leaflet</span><span class="p">(</span><span class="n">BF_malaria_localM</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="o">~</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="n">latitude</span><span class="p">,</span><span class="w"> </span><span class="n">fillOpacity</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w">
                                                               </span><span class="n">color</span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="n">factpal</span><span class="p">(</span><span class="n">names</span><span class="p">),</span><span class="w"> </span><span class="n">radius</span><span class="o">=</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">stroke</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addLegend</span><span class="p">(</span><span class="n">pal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factpal</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">title</span><span class="o">=</span><span class="s2">"Class"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-23-1.png" alt="" /></p>

<h2 id="part-ii-examining-spatial-point-processes">Part II: Examining spatial point processes</h2>

<p>In this section we’re going to look at a different type of point data,
point process data, and some of the tests we can use to examine spatial
autocorrelation in these data.</p>

<p>First we are going to load obfuscated malaria case data from northern
Namibia.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl</span><span class="o">&lt;-</span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/CaseControl.csv"</span><span class="p">)</span><span class="w">

</span><span class="c1">#  boundary file</span><span class="w">
</span><span class="n">NAM_Adm0</span><span class="o">&lt;-</span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s1">'GADM'</span><span class="p">,</span><span class="n">country</span><span class="o">=</span><span class="s1">'NAM'</span><span class="p">,</span><span class="n">level</span><span class="o">=</span><span class="m">0</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>We can convert the data to a SPDF and plot the cases and ‘controls’</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControl_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"long"</span><span class="p">,</span><span class="w"> </span><span class="s2">"lat"</span><span class="p">)],</span><span class="w">
                                           </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CaseControl</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"household_id"</span><span class="p">,</span><span class="w"> </span><span class="s2">"case"</span><span class="p">)])</span><span class="w">
</span><span class="n">cases</span><span class="o">&lt;-</span><span class="n">CaseControl_SPDF</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">1</span><span class="p">,]</span><span class="w">
</span><span class="n">controls</span><span class="o">&lt;-</span><span class="n">CaseControl_SPDF</span><span class="p">[</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="o">==</span><span class="m">0</span><span class="p">,]</span><span class="w">

</span><span class="c1"># Let's plot and see what we have</span><span class="w">
</span><span class="n">case_color_scheme</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"red"</span><span class="p">),</span><span class="w"> </span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">)</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">CaseControl_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">case_color_scheme</span><span class="p">(</span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">),</span><span class="w">
                                              </span><span class="n">radius</span><span class="o">=</span><span class="m">3</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-25-1.png" alt="" /></p>

<p>In the previous lecture, you already generated first order kernel
density estimates and calculated the ratio of the density estimate of
cases:controls. Now you will look at second order functions, summarizing
the spatial dependence between events</p>

<p>We need to change the case data to a PPP data type (‘point pattern’)</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CasesPPP</span><span class="o">&lt;-</span><span class="n">as</span><span class="p">(</span><span class="n">cases</span><span class="p">,</span><span class="w"> </span><span class="s2">"ppp"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>We use Ripley’s K function to summarize the spatial dependence between
events at a wide range of spatial scales</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K</span><span class="o">&lt;-</span><span class="n">Kest</span><span class="p">(</span><span class="n">CasesPPP</span><span class="p">,</span><span class="n">correction</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"isotropic"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Ripley"</span><span class="p">))</span><span class="w">    </span><span class="c1">#uses the "spatstat" package</span><span class="w">

</span><span class="n">par</span><span class="p">(</span><span class="n">mfrow</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="c1"># Plot the estimate of K(r); note different border-corrected estimates ('iso', 'border' and 'trans')</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"d (dd)"</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s2">"K(dd)"</span><span class="p">)</span><span class="w"> </span><span class="c1"># Red dashed line is expected K value computed for a CRS process</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-27-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E</span><span class="o">&lt;-</span><span class="n">envelope</span><span class="p">(</span><span class="n">CasesPPP</span><span class="p">,</span><span class="w"> </span><span class="n">Kest</span><span class="p">,</span><span class="w"> </span><span class="n">nsim</span><span class="o">=</span><span class="m">999</span><span class="p">)</span><span class="w"> </span><span class="c1"># Plot confidence envelope using MC simulation</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-29-1.png" alt="" /></p>

<p>The K-function computed for cases assumes that H0 is complete spatial
randomness. What are the limitations of this assumption?</p>

<p>Next we can look at the difference in Ripley’s K function between cases
and controls, using two approaches that do essentially the same thing;
#2 with hypothesis testing.</p>

<p>Approach 1: K function vignette from Bradley et al simply calculates the
K function for cases and controls, and evaluates the difference.</p>

<p>First create a marked point process.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CaseControlPPP</span><span class="o">&lt;-</span><span class="n">ppp</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">),</span><span class="w"> </span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">),</span><span class="w"> </span><span class="n">marks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.factor</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="p">))</span><span class="w">

</span><span class="c1"># Calculate the K-function for cases</span><span class="w">
</span><span class="n">KX</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Kest</span><span class="p">(</span><span class="n">CaseControlPPP</span><span class="p">[</span><span class="n">CaseControlPPP</span><span class="o">$</span><span class="n">marks</span><span class="o">==</span><span class="m">1</span><span class="p">],</span><span class="n">correction</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"isotropic"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Ripley"</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">KX</span><span class="p">,</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="n">iso</span><span class="o">/</span><span class="nb">pi</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-30-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculate the K-function for controls</span><span class="w">
</span><span class="n">KY</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">Kest</span><span class="p">(</span><span class="n">CaseControlPPP</span><span class="p">[</span><span class="n">CaseControlPPP</span><span class="o">$</span><span class="n">marks</span><span class="o">==</span><span class="m">0</span><span class="p">],</span><span class="n">correction</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"isotropic"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Ripley"</span><span class="p">))</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">KY</span><span class="p">,</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="n">iso</span><span class="o">/</span><span class="nb">pi</span><span class="p">)</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-30-2.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calulate the difference in the two functions</span><span class="w">
</span><span class="n">Kdiff</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">eval.fv</span><span class="p">(</span><span class="n">KX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">KY</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">Kdiff</span><span class="p">,</span><span class="w"> </span><span class="n">legendpos</span><span class="o">=</span><span class="s2">"float"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-30-3.png" alt="" /></p>

<p>Approach 2: “Smacpod” package includes a function to estimate the
difference in K function and plot simulated CI. Also includes a function
to the test the significance based on these simulations.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kdest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kdest</span><span class="p">(</span><span class="n">CaseControlPPP</span><span class="p">,</span><span class="w"> </span><span class="n">case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="n">nsim</span><span class="o">=</span><span class="m">999</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">0.95</span><span class="p">,</span><span class="w"> </span><span class="n">correction</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"isotropic"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Ripley"</span><span class="p">))</span><span class="w">  </span><span class="c1">#"smacpod" package</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 1 has been selected as the case group
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Note that the case = is position of the marks, not the value!  levels(CaseControlPPP$marks)</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">kdest</span><span class="p">)</span><span class="w"> </span><span class="c1"># dark grey is min/max; light grey is confidence envelope (can change these with options)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-32-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kdplus.test</span><span class="p">(</span><span class="n">kdest</span><span class="p">)</span><span class="w"> </span><span class="c1"># Performs test of significance based on simulated confidence envelope and observed statistic</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 
## Diggle and Chetwynd (1991) test for difference in K functions
## 
## KD(r) = K_case(r) - K_control(r)
## case label:  1 
## control label:  0 
## 
## null hypothesis: KD(r) = 0 for all r between 0 and 0.1653646 
## alternative hypothesis: KD(r) &gt; 0 for at least one r between 0 and 0.1653646 
## test statistic: 859.8309 
## p-value: 0.024 
## nsim: 999 
## simulation procedure: random labeling
</code></pre></div></div>

<h2 id="spatial-scan-statistics">Spatial Scan Statistics</h2>

<p>Finally we will look at spatial scan statistics using R.</p>

<p>On your own, you can also explore using SatScan, a free software tool
for spatial scan statistics that <a href="http://www.satscan.org/">you can find
here</a>.</p>

<p>For this exercise, we will use the “smacpod” library in R to run the
Kulldorf spatial scan statistic.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Convert CaseControl to a "PPP" object for spatial scan</span><span class="w">
</span><span class="n">CaseControlPPP</span><span class="o">&lt;-</span><span class="n">ppp</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">,</span><span class="w"> </span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">,</span><span class="w"> </span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">long</span><span class="p">),</span><span class="w"> </span><span class="nf">range</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">lat</span><span class="p">),</span><span class="w"> </span><span class="n">marks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">as.factor</span><span class="p">(</span><span class="n">CaseControl</span><span class="o">$</span><span class="n">case</span><span class="p">))</span><span class="w">

</span><span class="n">out</span><span class="o">&lt;-</span><span class="n">spscan.test</span><span class="p">(</span><span class="n">CaseControlPPP</span><span class="p">,</span><span class="w"> </span><span class="n">nsim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">999</span><span class="p">,</span><span class="w"> </span><span class="n">case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">maxd</span><span class="o">=</span><span class="m">.15</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.05</span><span class="p">)</span><span class="w">    </span><span class="c1"># "smacpod" library</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## 1 has been selected as the case group
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">CaseControlPPP</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-33-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case_color_scheme</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">colorNumeric</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s2">"blue"</span><span class="p">,</span><span class="w"> </span><span class="s2">"red"</span><span class="p">),</span><span class="w"> </span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">)</span><span class="w">
</span><span class="n">leaflet</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addTiles</span><span class="p">()</span><span class="w"> </span><span class="o">%&gt;%</span><span class="w"> </span><span class="n">addCircleMarkers</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">CaseControl_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">case_color_scheme</span><span class="p">(</span><span class="n">CaseControl_SPDF</span><span class="o">$</span><span class="n">case</span><span class="p">),</span><span class="w"> 
                                              </span><span class="n">stroke</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">fillOpacity</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="o">%&gt;%</span><span class="w"> 
  </span><span class="n">addCircles</span><span class="p">(</span><span class="n">lng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">$</span><span class="n">clusters</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="o">$</span><span class="n">coords</span><span class="p">[,</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">$</span><span class="n">clusters</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="o">$</span><span class="n">coords</span><span class="p">[,</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w">
             </span><span class="n">radius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">$</span><span class="n">clusters</span><span class="p">[[</span><span class="m">1</span><span class="p">]]</span><span class="o">$</span><span class="n">r</span><span class="o">*</span><span class="m">112</span><span class="o">*</span><span class="m">1000</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="o">=</span><span class="s2">"grey"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-4/unnamed-chunk-33-2.png" alt="" /></p>

<h2 id="key-readings">Key Readings</h2>

<p>Pullan, R. L., H. J. Sturrock, et al. (2012). “Spatial parasite ecology
and epidemiology: a review of methods and applications.” Parasitology
139(14): 1870-1887.</p>

<p>Pfeiffer DU, Robinson TP, Stevenson M, Stevens KB, Rogers DJ &amp; Clements
ACA (2008). Spatial Analysis in Epidemiology. Chapters 4 &amp; 5. Oxford
University Press, Oxford, UK.</p>

<h2 id="citation-for-the-leukemia-data">Citation for the leukemia data</h2>

<p>Turnbull, B. W. et al (1990) Monitoring for clusters of disease:
application to leukemia incidence in upstate New York American Journal
of Epidemiology, 132, 136-143</p>

<h2 id="other-good-resources">Other good resources</h2>

<p>Waller LA, Gotway CA (2004) Applied Spatial Statistics for Public Health
Data. John Wiley &amp; Sons, Hoboken, New Jersey.</p>

<ul>
  <li>R library rsatscan can be used to run SatScan from R, see also here:
<a href="https://www.satscan.org/rsatscan/rsatscan.html">rsatscan</a></li>
</ul>

<h2 id="selection-of-research-applications">Selection of research applications</h2>

<p>Bejon, P., T. N. Williams, et al. (2014). “A micro-epidemiological
analysis of febrile malaria in Coastal Kenya showing hotspots within
hotspots.” Elife 3: e02130.</p>

<p>Brooker S, Clarke S, Njagi JK, Polack S, Mugo B, Estambale B, Muchiri E,
Magnussen P &amp; Cox J (2004). Spatial clustering of malaria and associated
risk factors during an epidemic in a highland area of western Kenya.
Tropical Medicine and International Health 9: 757-766.</p>

<p>Fevre EM, Coleman PG, Odiit M, et al. (2001). The origins of a new
Trypanosoma brucei rhodesiense sleeping sickness outbreak in eastern
Uganda. Lancet 358: 625-628.</p>

<p>Huillard d’Aignaux J, Cousens SN, Delasnerie-Laupretre N, Brandel JP,
Salomon D, Laplanche JL, Hauw JJ &amp; Alperovitch A (2002). Analysis of the
geographical distribution of sporadic Creutzfeldt-Jakob disease in
France between 1992 and 1998. International Journal of Epidemiology 31:
490-495.</p>

<p>Gaudart J, Poudiougou B, Dicko A, et al. (2006). Space-time clustering
of childhood malaria at the household level: a dynamic cohort in a Mali
village. BMC Public Health 6: 286.</p>

<p>Kulldorff M, Athas WF, Feuer EJ, Miller BA &amp; Key CR (1998). Evaluating
cluster alarms: A Space-Time Scan Statistic and Brain Cancer in Los
Alamos, New Mexico. American Journal of Public Health 88, 1377-1380.</p>

<p>Kulldorff M &amp; Nagarwalla N (1995). Spatial disease clusters: Detection
and inference. Statistics in Medicine 14, 799-819. Odoi A, Martin SW,
Michel P, et al. (2004). Investigation of clusters of giardiasis using
GIS and a spatial scan statistic. Int J Health Geogr 3: 11.</p>

<p>Mosha, J. F., H. J. Sturrock, et al. (2014). “Hot spot or not: a
comparison of spatial statistical methods to predict prospective malaria
infections.” Malar J 13: 53.</p>

<p>Ngowi HA, Kassuku AA, Carabin H, et al. (2010). Spatial clustering of
porcine cysticercosis in Mbulu district, northern Tanzania. PLoS Negl
Trop Dis 4: e652.</p>

<p>Peterson I, Borrell LN, El-Sadr W, et al. (2009). A temporal-spatial
analysis of malaria transmission in Adama, Ethiopia. Am J Trop Med Hyg
81: 944-949.</p>

<p>Sissoko, M. S., L. L. van den Hoogen, et al. (2015). “Spatial Patterns
of Plasmodium falciparum Clinical Incidence, Asymptomatic Parasite
Carriage and Anopheles Density in Two Villages in Mali.” Am J Trop Med
Hyg 93(4): 790-797.</p>

<p>Washington CH, Radday J, Streit TG, et al. (2004). Spatial clustering of
filarial transmission before and after a Mass Drug Administration in a
setting of low infection prevalence. Filaria J 3: 3.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Aim]]></summary></entry><entry><title type="html">Week 1 - Visualizing spatial data</title><link href="http://localhost:4000/week-1/" rel="alternate" type="text/html" title="Week 1 - Visualizing spatial data" /><published>2022-02-24T00:00:00-08:00</published><updated>2022-02-24T00:00:00-08:00</updated><id>http://localhost:4000/week-1</id><content type="html" xml:base="http://localhost:4000/week-1/"><![CDATA[<p>Welcome to week 1 of spatial analysis for public health. This week we
will be learning about the process of moving from visualizing spatial
data through to exploration and analysis. We will get our hands dirty
with some R code and learn how to make beautiful maps. This week’s
lecture will focus on some of the concepts behind spatial epidemiology.
The code below covers loading and visualizing spatial data in R. You
will then have a chance to apply that code to new data and questions in
this week’s assignment.</p>

<h2 id="lab-1-working-with-spatial-data-in-r">Lab 1: Working with Spatial Data in R</h2>

<p>The simplest data is a table with coordinates (i.e. point data). For
this assignment, we’ll work with malaria prevalence point data from
Ethiopia. These data were downloaded from the Malaria Atlas Project data
repository and were originally collected as part of <a href="https://link.springer.com/article/10.1186/1475-2875-10-25">a
study</a>
conducted in 2009.</p>

<p>First get the necessary libraries for this week</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">raster</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">rgdal</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Please note that rgdal will be retired by the end of 2023,
## plan transition to sf/stars/terra functions using GDAL and PROJ
## at your earliest convenience.
## 
## rgdal: version: 1.5-28, (SVN revision 1158)
## Geospatial Data Abstraction Library extensions to R successfully loaded
## Loaded GDAL runtime: GDAL 3.2.1, released 2020/12/29
## Path to GDAL shared files: /Users/David/Library/R/x86_64/4.1/library/rgdal/gdal
## GDAL binary built with GEOS: TRUE 
## Loaded PROJ runtime: Rel. 7.2.1, January 1st, 2021, [PJ_VERSION: 721]
## Path to PROJ shared files: /Users/David/Library/R/x86_64/4.1/library/rgdal/proj
## PROJ CDN enabled: FALSE
## Linking to sp version:1.4-6
## To mute warnings of possible GDAL/OSR exportToProj4() degradation,
## use options("rgdal_show_exportToProj4_warnings"="none") before loading sp or rgdal.
## Overwritten PROJ_LIB was /Users/David/Library/R/x86_64/4.1/library/rgdal/proj
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">library</span><span class="p">(</span><span class="n">leaflet</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Import the data</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"https://raw.githubusercontent.com/phw272c/phw272c.github.io/master/data/mal_data_eth_2009_no_dups.csv"</span><span class="p">,</span><span class="w"> </span><span class="n">header</span><span class="o">=</span><span class="nb">T</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>The columns should be self-explanatory, but briefly: * examined =
numbers tested * pf_pos = of those tested, how many were positive for
Plasmodium falciparum malaria * pf_pr = Plasmodium falciparum parasite
rate which is the same as infection prevalence or proportion infected
(i.e. pf_pos / examined) * longitude = longitude of school in decimal
degrees * latitude = latitude of schoolin decimal degrees</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Look at the first few rows</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##    country country_id continent_id site_id          site_name latitude
## 1 Ethiopia        ETH       Africa    6694        Dole School   5.9014
## 2 Ethiopia        ETH       Africa    8017     Gongoma School   6.3175
## 3 Ethiopia        ETH       Africa   12873      Buriya School   7.5674
## 4 Ethiopia        ETH       Africa    6533       Arero School   4.7192
## 5 Ethiopia        ETH       Africa    4150     Gandile School   4.8930
## 6 Ethiopia        ETH       Africa    1369 Melka Amana School   6.2461
##   longitude rural_urban year_start lower_age upper_age examined pf_pos
## 1   38.9412     UNKNOWN       2009         4        15      220      0
## 2   39.8362     UNKNOWN       2009         4        15      216      0
## 3   40.7521     UNKNOWN       2009         4        15      127      0
## 4   38.7650     UNKNOWN       2009         4        15       56      0
## 5   37.3632     UNKNOWN       2009         4        15      219      0
## 6   39.7891     UNKNOWN       2009         4        15      215      1
##         pf_pr     method
## 1 0.000000000 Microscopy
## 2 0.000000000 Microscopy
## 3 0.000000000 Microscopy
## 4 0.000000000 Microscopy
## 5 0.000000000 Microscopy
## 6 0.004651163 Microscopy
##                                                                                                                                title1
## 1 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
## 2 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
## 3 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
## 4 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
## 5 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
## 6 School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.
##                                                                                                                                                                                                                                                                                               citation1
## 1 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
## 2 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
## 3 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
## 4 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
## 5 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
## 6 Ashton, RA, Kefyalew, T, Tesfaye, G, Pullan, RL, Yadeta, D, Reithinger, R, Kolaczinski, JH and Brooker, S (2011).  &lt;b&gt;School-based surveys of malaria in Oromia Regional State, Ethiopia: a rapid survey method for malaria in low transmission settings.&lt;/b&gt; &lt;i&gt;Malaria Journal&lt;/i&gt;, &lt;b&gt;10&lt;/b&gt;(1):25
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a histogram of the prevalence</span><span class="w">
</span><span class="n">hist</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="p">,</span><span class="w"> </span><span class="n">breaks</span><span class="o">=</span><span class="m">20</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-3-1.png" alt="" /></p>

<h1 id="plotting-and-mapping-spatial-data">Plotting and mapping spatial data</h1>

<p>It is possible to use R’s base graphics to plot points, treating them
like any other data with x and y coordinates. For example, to get a plot
of the points alone</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Latitude"</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Longitude"</span><span class="p">)</span><span class="w"> </span><span class="c1">#boring!</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-4-1.png" alt="" /></p>

<p>You might want to vary the size of the circle as a function of a
variable. For example, if we wanted to plot points with size relative to
prevalence we can use the expansion argument <code class="language-plaintext highlighter-rouge">cex</code></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Use the cex function to plot circle size as a function of a variable. In this case prevalence. As the values are very small we can multiply by an arbitrary amount for visualization purposes</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
     </span><span class="n">cex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Latitude"</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Longitude"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-5-1.png" alt="" /></p>

<h2 id="working-with-spatial-objects">Working with ‘Spatial’ objects</h2>

<p>In R, it is sometimes useful to package spatial data up into a ‘Spatial’
class of object using the <code class="language-plaintext highlighter-rouge">sp</code> package. This often makes it easier to
work with and is often a requirement for other functions. The
<a href="https://cran.r-project.org/web/packages/sp/index.html">sp</a> package
allows you to put your data into specific spatial objects, such as
<code class="language-plaintext highlighter-rouge">SpatialPoints</code> or <code class="language-plaintext highlighter-rouge">SpatialPolygons</code>. In addition, if your data are more
than just the geometry, i.e. if you have data associated with each
spatial feature, you can create spatial DataFrames,
i.e. <code class="language-plaintext highlighter-rouge">SpatialPointsDataFrames</code> and <code class="language-plaintext highlighter-rouge">SpatialPolygonsDataFrames</code>. For
example, if we wanted to create a SpatalPointsDataFrame using the
Ethiopia data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ETH_malaria_data_SPDF</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SpatialPointsDataFrame</span><span class="p">(</span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"longitude"</span><span class="p">,</span><span class="w"> </span><span class="s2">"latitude"</span><span class="p">)],</span><span class="w">
                                      </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="p">[,</span><span class="nf">c</span><span class="p">(</span><span class="s2">"examined"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pf_pos"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pf_pr"</span><span class="p">)],</span><span class="w">
                                      </span><span class="n">proj4string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CRS</span><span class="p">(</span><span class="s2">"+init=epsg:4326"</span><span class="p">))</span><span class="w"> </span><span class="c1"># sets the projection to WGS 1984 using lat/long. Optional but good to specify</span><span class="w">

</span><span class="c1"># Summary of object</span><span class="w">
</span><span class="n">ETH_malaria_data_SPDF</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class       : SpatialPointsDataFrame 
## features    : 203 
## extent      : 34.5418, 42.4915, 3.8966, 9.9551  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs 
## variables   : 3
## names       : examined, pf_pos,       pf_pr 
## min values  :       37,      0,           0 
## max values  :      221,     14, 0.127272727
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># SPDFs partition data elements, e.g. the coordinates are stored separately from the data</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">@</span><span class="n">coords</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##      longitude latitude
## [1,]   38.9412   5.9014
## [2,]   39.8362   6.3175
## [3,]   40.7521   7.5674
## [4,]   38.7650   4.7192
## [5,]   37.3632   4.8930
## [6,]   39.7891   6.2461
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">@</span><span class="n">data</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>##   examined pf_pos       pf_pr
## 1      220      0 0.000000000
## 2      216      0 0.000000000
## 3      127      0 0.000000000
## 4       56      0 0.000000000
## 5      219      0 0.000000000
## 6      215      1 0.004651163
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># You can quickly access the data frame as per a standard data frame, e.g.</span><span class="w">
</span><span class="n">head</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="o">$</span><span class="n">pf_pr</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## [1] 0.000000000 0.000000000 0.000000000 0.000000000 0.000000000 0.004651163
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># You can use the plot or spplot function to get quick plots</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-6-1.png" alt="" /></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spplot</span><span class="p">(</span><span class="n">ETH_malaria_data_SPDF</span><span class="p">,</span><span class="w"> </span><span class="n">zcol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"pf_pr"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-6-2.png" alt="" /></p>

<p>Let’s have a look at SpatialPolygonsDataFrames. To load a polygon
shapefile (or other file types), you can use the <code class="language-plaintext highlighter-rouge">readOGR</code> function from
the <code class="language-plaintext highlighter-rouge">rgdal</code> package. For example, if you wanted to load in the province
boundaries for Ethiopia shapefile <code class="language-plaintext highlighter-rouge">ETH_Adm_1</code> from the
<code class="language-plaintext highlighter-rouge">ETH_Adm_1_shapefile</code> folder on
<a href="https://github.com/phw272c/phw272c.github.io/tree/master/data/ETH_Adm_1_shapefile">GitHub</a>,
assuming you have downloaded the folder of files you would use the
following command</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETH_Adm_1 &lt;- readOGR("ETH_Adm_1_shapefile", "ETH_Adm_1")
</code></pre></div></div>

<p>As it happens, admin boundary data is accessible using the <code class="language-plaintext highlighter-rouge">getData</code>
function from the <code class="language-plaintext highlighter-rouge">raster</code> package. Be careful as some other packages
also have a <code class="language-plaintext highlighter-rouge">getData</code> function, so to specify that you want to use the
<code class="language-plaintext highlighter-rouge">getData</code> function from the <code class="language-plaintext highlighter-rouge">raster</code> package you can use the following
code</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># You first need the ISO3 codes for the country of interest. You can access these using `ccodes()`. For Ethiopia, the ISO3 is ETH</span><span class="w">

</span><span class="c1"># The getData function then allows you to retrieve the relevant admin level boundaries from GADM.</span><span class="w">
</span><span class="n">ETH_Adm_1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"GADM"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w"> 
</span></code></pre></div></div>

<p>Now we can plot the point data in context</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plot both country and data points</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">ETH_Adm_1</span><span class="p">)</span><span class="w">
</span><span class="n">points</span><span class="p">(</span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">longitude</span><span class="p">,</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">latitude</span><span class="p">,</span><span class="w">
     </span><span class="n">cex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ETH_malaria_data</span><span class="o">$</span><span class="n">pf_pr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w">
     </span><span class="n">ylab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Latitude"</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s2">"Longitude"</span><span class="p">,</span><span class="w">
     </span><span class="n">col</span><span class="o">=</span><span class="s2">"red"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-8-1.png" alt="" /></p>

<h1 id="plotting-data-using-web-maps">Plotting data using web maps</h1>

<p>Rather than just relying on R base graphics, we can easily create
webmaps using the <code class="language-plaintext highlighter-rouge">leaflet</code> package. There are many basemaps available.
See <a href="https://leaflet-extras.github.io/leaflet-providers/preview/">here</a>.
For any map, identify the Provider name, e.g. ”OpenStreetMap.Mapnik”, by
clicking on the map.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Define your basemap
basemap &lt;- leaflet() %&gt;% addTiles()
basemap

# Or choose another basemap
basemap &lt;- leaflet() %&gt;% addProviderTiles("Esri.WorldImagery")
basemap

#Let's choose a simple one
basemap &lt;- leaflet() %&gt;% addProviderTiles("CartoDB.Positron")
</code></pre></div></div>

<p>You can use the ‘piping’ command %&gt;% to add layers. As our point and
polygon data are already ‘Spatial’ object this is easy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>basemap %&gt;% addPolygons(data=ETH_Adm_1)


# to change the colors/line weight
basemap %&gt;% addPolygons(data=ETH_Adm_1, color = "red", 
                        weight = 1, fillOpacity = 0.2)

#You can also add popups
basemap %&gt;% addPolygons(data=ETH_Adm_1, 
                        popup = ETH_Adm_1$NAME_1)

# If you want to add points as well
basemap %&gt;% addPolygons(data=ETH_Adm_1, weight = 2,
                        popup = ETH_Adm_1$NAME_1) %&gt;%
  
            addCircleMarkers(data=ETH_malaria_data_SPDF,
                             color="red", radius = 2)
</code></pre></div></div>

<p>The leaflet package also has some nice functions for generate color
palettes that map to a variable you want to display. For example, if we
wanted to create a color ramp relative to prevalence we could use the
<code class="language-plaintext highlighter-rouge">colorQuantile</code> function. See ?colorQuantile for other ways to build
color palettes such as <code class="language-plaintext highlighter-rouge">colorNumeric</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(wesanderson) # for a nice color palette
colorPal &lt;- colorNumeric(wes_palette("Zissou1")[1:5], ETH_malaria_data_SPDF$pf_pr, n = 5)

# colorPal is now a function you can apply to get the corresponding
# color for a value
colorPal(0.1)

basemap %&gt;% addPolygons(data=ETH_Adm_1, weight = 2, fillOpacity=0,
                        popup = ETH_Adm_1$NAME_1,
                        color = "gray") %&gt;%
  
  addCircleMarkers(data=ETH_malaria_data_SPDF,
                   color = colorPal(ETH_malaria_data_SPDF$pf_pr), 
                   radius = 2,
                   popup = as.character(ETH_malaria_data_SPDF$pf_pr))
</code></pre></div></div>

<p>You might want to add a legend. This just goes on as another layer on
the map. First define the labels. In this case, we are using quintiles.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>basemap %&gt;% addPolygons(data=ETH_Adm_1, weight = 2, fillOpacity=0,
                        popup = ETH_Adm_1$NAME_1,
                        color = "gray") %&gt;%
  
  addCircleMarkers(data=ETH_malaria_data_SPDF,
                   color = colorPal(ETH_malaria_data_SPDF$pf_pr), 
                   radius = 2,
                   popup = as.character(ETH_malaria_data_SPDF$pf_pr)) %&gt;%
  
  addLegend(pal = colorPal, 
            title = "Prevalence",
            values = ETH_malaria_data_SPDF$pf_pr )
</code></pre></div></div>

<p>For more complex popups, you can define the HTML</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>basemap %&gt;% addPolygons(data=ETH_Adm_1, weight = 2, fillOpacity=0,
                        popup = ETH_Adm_1$NAME_1,
                        color = "gray") %&gt;%
  
  addCircleMarkers(data=ETH_malaria_data_SPDF,
                   color = colorPal(ETH_malaria_data_SPDF$pf_pr), 
                   radius = 2,
                   popup = paste("&lt;p&gt;","Prevalence:",
                                 round(ETH_malaria_data_SPDF$pf_pr,2),
                                 "&lt;p&gt;")) %&gt;%
                                 
 addLegend(pal = colorPal, 
            title = "Prevalence",
            values = ETH_malaria_data_SPDF$pf_pr )
</code></pre></div></div>

<h1 id="plotting-raster-data">Plotting raster data</h1>

<p>If you have a local raster file (e.g. a .tif file), you can use the
<code class="language-plaintext highlighter-rouge">raster</code> command to load the file into R. For example, if you download
the
<a href="https://github.com/phw272c/phw272c.github.io/blob/master/data/elev_ETH.tif?raw=true">“elev_ETH.tif”</a>
file from this week’s data, you would use the following to load from a
local source:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>elev &lt;- raster("elev_ETH.tif")
</code></pre></div></div>

<p>You can also load using a URL, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>elev &lt;- raster("https://github.com/phw272c/phw272c.github.io/blob/master/data/elev_ETH.tif?raw=true")
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">getData</code> functon from the <code class="language-plaintext highlighter-rouge">raster</code> package allows you to get hold
of some select raster data, such as elevation and bioclimatic layers. To
get hold of elevation for Ethiopia, use the following</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elev</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">raster</span><span class="o">::</span><span class="n">getData</span><span class="p">(</span><span class="s2">"alt"</span><span class="p">,</span><span class="w"> </span><span class="n">country</span><span class="o">=</span><span class="s2">"ETH"</span><span class="p">)</span><span class="w">
</span><span class="n">elev</span><span class="w">
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## class      : RasterLayer 
## dimensions : 1416, 1824, 2582784  (nrow, ncol, ncell)
## resolution : 0.008333333, 0.008333333  (x, y)
## extent     : 32.9, 48.1, 3.2, 15  (xmin, xmax, ymin, ymax)
## crs        : +proj=longlat +datum=WGS84 +no_defs 
## source     : ETH_msk_alt.grd 
## names      : ETH_msk_alt 
## values     : -189, 4420  (min, max)
</code></pre></div></div>

<p>You can plot using the plot function</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plot</span><span class="p">(</span><span class="n">elev</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../images/week-1/unnamed-chunk-10-1.png" alt="" /></p>

<p>Alternatively, you can use leaflet</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>basemap %&gt;% addRasterImage(elev)
</code></pre></div></div>

<p>If you want to add a legend, you have to define the color palette first</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Define palette
raster_colorPal &lt;- colorNumeric(topo.colors(64), values(elev), na.color = NA)

# Plot
basemap %&gt;% addRasterImage(elev, color = raster_colorPal) %&gt;%
addLegend(values = values(elev), pal = raster_colorPal)
</code></pre></div></div>

<p>If you want to export the data, there are several options.</p>

<ol>
  <li>
    <p>Export button in the Viewer pane. Using ‘Save as webpage’ creates an
html file which you can open using a browser.</p>
  </li>
  <li>
    <p>Save as kml for someone to open in Google Earth</p>
  </li>
</ol>

<pre><code class="language-{=html}">&lt;!-- --&gt;
</code></pre>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library(plotKML)
plotKML(ETH_malaria_data_SPDF) # see ?plotKML for more options
</code></pre></div></div>

<h1 id="pop-quiz">Pop quiz</h1>

<p>When using the base graphics to plot point data, how might you make the
points larger, but still relative to prevalence?</p>

<h2 id="resources">Resources</h2>

<p>The R packages
<a href="https://cran.r-project.org/web/packages/sp/index.html">sp</a> and
<a href="https://cran.r-project.org/web/packages/raster/index.html">raster</a> are
both important packages for spatial analysis.</p>

<p>R studio also have a fantastic
<a href="https://rstudio.github.io/leaflet/">site</a> outlining the use of leaflet</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Welcome to week 1 of spatial analysis for public health. This week we will be learning about the process of moving from visualizing spatial data through to exploration and analysis. We will get our hands dirty with some R code and learn how to make beautiful maps. This week’s lecture will focus on some of the concepts behind spatial epidemiology. The code below covers loading and visualizing spatial data in R. You will then have a chance to apply that code to new data and questions in this week’s assignment.]]></summary></entry></feed>